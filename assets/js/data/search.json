[ { "title": "Android ‚Äî ViewModel factory and instantiation", "url": "/posts/viewmodel-store/", "categories": "Android, ViewModel", "tags": "android, viewmodel", "date": "2021-10-01 00:00:00 +0530", "snippet": "Android ViewModel is one of the most helpful APIs exist in the ecosystem. It‚Äôs a major release which changed how the Android apps built. Together with LiveData it decoupled the UI from business logic without much boilerplate. This post is about how the viewmodel is instatiated/cached/provided to the caller.üìù API docBefore we get into specific usecases, let‚Äôs see few key players in this flow.‚Ä¶FactoryFactory is an interface responsible for instantiating a viewmodel. It may or may not inject dependencies to the viewmodel.‚Ä¶ViewModelStore &amp;amp; ViewModelStoreOwnerViewModelStore keeps a hashmap of String &amp;amp; ViewModel. Once instantiated, viewmodel is stored in it. ViewModelStoreOwner is an interface implemented by Activity/Fragment. Under the hood a ViewModelStore is used by fragment/activity to store the reference.‚Ä¶ViewModelProviderViewModelProvider is an umbrella object that coordinates Factory and ViewModelStore. Responsibility of this class is identifying the factory and caching viewmodel reference to ViewModelStore. There could be number of ViewModelProviders created in a fragment/activity. But when a viewmodel is requested, all of them will return the same instance. This is due to ViewModelStore‚Äôs single source of truth nature.üèóÔ∏è InstantiationNote: Jetpack recommends viewModels / activityViewModels delegates to instantiate a ViewModel. However, for clarity this article will explain the usecases through ViewModelProvider instances.ViewModel without any constructor argumentsThis is a rare case where viewmodel doesn‚Äôt need any dependency. To instantiate such basic viewmodel, create a ViewModelProvider with current activity/fragment reference and invoke get method with ViewModel‚Äôs class.val viewModel = ViewModelProvider(this) // Create reference wrt current fragment .get(ProfileViewModel::class.java) // query for a ProfileViewModel‚Ä¶ViewModel with dependenciesMost common pattern with viewmodel is to pass constructor arguments (of data source) and do CRUD and emit events through LiveData. This can be done by creating a custom Factory and use it in place of default one. Internally, ViewModelProvider will use this factory to create the instance and store it to the viewmodelstore. Let‚Äôs see how it‚Äôs done. Create a Factory which forwards constructor arguments to the ViewModel. This implements ViewModelProvider.Factory. class ProfileViewModel(private val repo: DataRepository) : ViewModel() { class Factory(private val repo: DataRepository) : ViewModelProvider.Factory { override fun &amp;lt;T : ViewModel?&amp;gt; create(modelClass: Class&amp;lt;T&amp;gt;): T { return ProfileViewModel(repo) as T } }} Inside the fragment/activity, create a factory instance. And pass it to ViewModelProvider.val dataRepo = DataRepoImpl() // Data sourceval factory = ProfileViewModel.Factory(dataRepo) // FactoryViewModelProvider(this, factory).get(ProfileViewModel::class.java) // ViewModel‚Ä¶Interesting thing about the ViewModelProvider is after instantiating the ViewModel in the scope (activity/fragment) next time invoking it will return the same viewmodel. That isViewModelProvider(this).get(ProfileViewModel::class.java)will return the ViewModel created in second step. The order of calls matterns here.ü§î Few questionsHow ViewModel survives orientation change?This is not specific to ViewModel, but any retained object across activity recreation due to configuration change (orientation/locale). Android‚Äôs activity (yes!! The original activity) has onRetainNonConfigurationInstance method which can pass around objects between old and recreated activity instances. getLastNonConfigurationInstance can capture the same in newly instantiated activity.Catch is these methods are deprecated in favor of ViewModel which can achieve the same in a very graceful manner. To answer the question, ViewModelStore is passed between the activity instances.How ViewModel is scoped to single Fragment?When creating a Fragment with its scope, a nested ViewModelStore is created from its parent scope. This is applicable for Fragment inside an activity or even fragment. Few snippets to clarify things.// FragmentManager.javaif (host instanceof ViewModelStoreOwner) { ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore(); mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);}// FragmentManagerViewModel.javafinal class FragmentManagerViewModel extends ViewModel { private final HashMap&amp;lt;String, ViewModelStore&amp;gt; mViewModelStores = new HashMap&amp;lt;&amp;gt;(); @NonNull ViewModelStore getViewModelStore(@NonNull Fragment f) { ViewModelStore viewModelStore = mViewModelStores.get(f.mWho); if (viewModelStore == null) { viewModelStore = new ViewModelStore(); mViewModelStores.put(f.mWho, viewModelStore); } return viewModelStore; } // Fragment.java // Internal unique name for this fragment; @NonNull String mWho = UUID.randomUUID().toString();}This is how it works, Each fragment manager contains a FragmentManagerViewModel FragmentManagerViewModel contains a map of string vs viewmodelstore string in above step is UUID generated for each fragment and viewmodelstore is the one we‚Äôve seen in API doc section.How unique is the key in ViewModelStore?From ViewModelProvider who puts viewmodels into the ViewModelStore. Key is just the CanonicalName of the ViewModel. So, it‚Äôs purely based in class name. Since every fragment get its own store, it will not collide. Same makes it possible that fragments of the same activity to share viewmodels. private static final String DEFAULT_KEY = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;; @NonNull @MainThread public &amp;lt;T extends ViewModel&amp;gt; T get(@NonNull Class&amp;lt;T&amp;gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); } return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass); }üìí Resources Activity ViewModelProvider" }, { "title": "Android ‚Äî Basic Hilt setup with viewmodel + fragment", "url": "/posts/hilt-viewmodel/", "categories": "Android, Hilt", "tags": "android, hilt, dagger", "date": "2021-09-28 00:00:00 +0530", "snippet": "Hilt is a modern android DI framework for dependency injection. It is merely a wrapper around Dagger2. Forget dagger-android, hilt brings a lot to our plate. This article covers steps to add hilt to the project and use along with viewmodel-fragment.‚Ä¶This is the first installment in three part series.Part1: Android ‚Äî Basic Hilt setup with viewmodel + fragmentPart2: Smoke, mirrors &amp;amp; HiltViewModelPart3: Fakes and espresso‚Ä¶Sample project used for this article is available in github.üíâ What are we injecting?For this example, we‚Äôre going to provide Profile (a POJO) to a fragment through ViewModel. For simplicity let‚Äôs not use LiveData in here. This is how the dependency graph looks like.üîò Little about scopeDependencies could be of different scope (how long it can be in memory/when it can be garbage collected). When we speak about the scope of a dependency, we can easily define it in terms of android components. Below is the oversimplified version of commonly used scopes. A user session details should be available throughout the app (Singleton) I have a tabbed screen and want to share some in-memory fields between fragments (Activity) My data is bound to current screen/fragment. When it is destroyed purge the dependency as well (Fragment) Associate my dependency with ViewModel. Depends on the viewmodel‚Äôs scope (activity / fragment) let my dependency live (ViewModelScope)For our use-case, we‚Äôll inject DataRepository to the viewmodel using hilt. And there are few improvements on creating viewmodel for the fragment. We‚Äôll see it end to end in the following section.üíª Code itBuild setupLike any framework we write less with hilt because most of the code is generated for us. For that purpose, we‚Äôll use hilt gradle plugin. And, hilt is expected to be used in multiple modules, so extract out the version to project level gradle file and use it in submodules.// File: build.gradlebuildscript { ext { hilt_version = &#39;2.38.1&#39; } repositories { // redacted } dependencies { // redacted classpath &quot;com.google.dagger:hilt-android-gradle-plugin:${hilt_version}&quot; }}// File: app/build.gradleplugins { id &#39;com.android.application&#39; id &#39;kotlin-android&#39; id &#39;dagger.hilt.android.plugin&#39;}dependencies { // Hilt implementation &quot;com.google.dagger:hilt-android:${hilt_version}&quot; kapt &quot;com.google.dagger:hilt-compiler:${hilt_version}&quot; // Fragment / viewmodel def lifecycle = &quot;2.3.1&quot; implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:${lifecycle}&quot; implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:${lifecycle}&quot; implementation &quot;androidx.fragment:fragment-ktx:1.3.6&quot;}In the project level gradle we tell the build system to use hilt. And the app level gradle applies the plugin so that it can skim through our codebase and generate dependencies for us.‚Ä¶HiltAndroidApp setup (application context)A singleton is expected to be alive through the app session. Here, the dependency lives with application. In order to tell hilt about the application scope, create and annotate application class with HiltAndroidApp.import android.app.Applicationimport dagger.hilt.android.HiltAndroidApp@HiltAndroidAppclass MyApp : Application()Above step is needed because the application context is provided through generated application class. Make the project and inspect the contents of Hilt_MyApp class.// generated sourceDaggerMyApp_HiltComponents_SingletonC.builder() .applicationContextModule(new ApplicationContextModule(Hilt_MyApp.this)) .build();Above steps enables smoother injection of application context to RoomDB / SharedPreference - what not.‚Ä¶Creating data source and modulesCode speaks thousand words. Below code block shows resource and the data source.// A resourcedata class Profile( val name: String, val age: Int)// A simple interface which returns the resource. // This will help us mock the data source when executing tests.interface DataRepository { fun getProfile(): Profile}// Simple implementation of data sourceclass DataRepoImpl : DataRepository { override fun getProfile(): Profile = Profile(name = &quot;Bruce Wayne&quot;, age = 42)}From here, we‚Äôll work towards creating dependencies that can be recognized by Hilt.First, annotate DataRepoImpl constructor with @Inject. This puts our class under Dagger/Hilt‚Äôs radar.class DataRepoImpl @Inject constructor() : DataRepository {Second, create a module that can provide dependency to view model.@InstallIn(ViewModelComponent::class) // Scope our dependencies@Moduleabstract class ProfileModule { // To be read as ‚Äî When someone asks for DataRepository, create a DataRepoImpl and return it. @Binds abstract fun getProfileSource(repo: DataRepoImpl): DataRepository}‚Ä¶Viewmodel setupViewModels can tell ask hilt to provide dependencies. A simple way to ask dependencies is to mark viewmodel with HiltViewModel annotation.@HiltViewModelclass ProfileViewModel @Inject constructor( private val repo: DataRepository) : ViewModel() { fun getProfile(): Profile = repo.getProfile()}Here we‚Äôre doing constructor injection on viewmodel. Doing the same without Hilt will require a Factory which pass on the dependencies to the constructor. Reason is the lifecycle of the viewmodel is managed by a lifecycle owner like activity/fragment. Internal mechanics of this injection is covered in last section. On to the fragment‚Ä¶‚Ä¶Fragment setupFragment or activity is identified as AndroidEntryPoint in hilt. A fragment which is maked with AndroidEntryPoint will inject the dependencies without much boilerplate code. And this is our ProfileFragment which consumes the viewmodel.@AndroidEntryPointclass ProfileFragment : Fragment() { private val viewModel by viewModels&amp;lt;ProfileViewModel&amp;gt;() // redacted override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // Here we go -- the profile resource is shown to the UI view.findViewById&amp;lt;TextView&amp;gt;(R.id.name_label) .text = viewModel.getProfile().name }}That‚Äôs it!!Nothing much changed, instead of creating a factory and use it in viewModels delegate we annotated with AndroidEntryPoint. And the resource is available to us and components are less coupled now.üìñ Resources Sample project source dagger.dev Commit: migrating from manual injection to hilt" }, { "title": "Designing a bottom navigation bar with Jetpack compose", "url": "/posts/compose-bottom-bar/", "categories": "Android, Compose", "tags": "android, compose", "date": "2021-07-30 00:00:00 +0530", "snippet": "IntroThis article covers the design aspect of the bottom navigation bar using Jetpack compose. We‚Äôre looking at a simple composable with few customizable params for the icons. Take this as an approach doc for designing UI rather than an API guide. The result will look like this.üìê AnalysisLet‚Äôs dissect this view and see how to build this. This is a row with equal space around each icon At a time only one icon can be selected All the icons are of the same size except the selected one, which is at 1.5x Row accounts for the larger icon as well and all the icons are vertically center alignedInteractionsWhen an icon is selected, it scales up to 1.5x and changes its color change to blue. And previously selected icon resets to 1x and goes back to grey color. This transition is not sudden and happens over a particular time.üèóÔ∏è Building the UIUI is straightforward here. Icons and a Row that holds them. So, the first step is to prepare a few ingredients to build the UI. Add material extended icons in Gradle dependency and pick some for the navbar.private val navBarItems = arrayOf( Icons.Outlined.Home, Icons.Outlined.Send, Icons.Outlined.FavoriteBorder, Icons.Outlined.PersonOutline,)Choose two colors for selected and unselected state:private val COLOR_NORMAL = Color(0xffEDEFF4)private val COLOR_SELECTED = Color(0xff496DE2)Define a base icon size. This will be scaled up to 1.5x when selected. Also, it‚Äôs a good practice to make most of the properties configurable with default values. After all, we‚Äôre dealing with functions here.private val ICON_SIZE = 24.dp‚Ä¶Let‚Äôs start with icons and build a row of them.Animated icons:From the icons aspect, it hoists its click to the parent and expects its parent to tell which state it should move to. The icon has one responsibility - to animate its color and scale when the properties are set. It doesn‚Äôt know about its state. All it knows is to smoothly change the values. Quick note about compose animation - it always tries to transition from the current value to the target value. Asking for the start value might lead to a jump in animations, which is avoided here. IMO compose team did it well here.@Composablefun AnimatableIcon( imageVector: ImageVector, modifier: Modifier = Modifier, iconSize: Dp = ICON_SIZE, scale: Float = 1f, color: Color = COLOR_NORMAL, onClick: () -&amp;gt; Unit) { // Animation params val animatedScale: Float by animateFloatAsState( targetValue = scale, // Here the animation spec serves no purpose but to demonstrate in slow speed. animationSpec = TweenSpec( durationMillis = 2000, easing = FastOutSlowInEasing ) ) val animatedColor by animateColorAsState( targetValue = color, animationSpec = TweenSpec( durationMillis = 2000, easing = FastOutSlowInEasing ) ) IconButton( onClick = onClick, modifier = modifier.size(iconSize) ) { Icon( imageVector = imageVector, contentDescription = &quot;dummy&quot;, tint = animatedColor, modifier = modifier.scale(animatedScale) ) }}Animated icon composable holds two animatable values and is set to corresponding attributes. To interact with its parent, it exposes an onClick lambda. And animation target values are passed from the parent.‚Ä¶Before plug this into Row, try it out with a preview. As our icon is a dumb view, the preview will have unusual responsibilities. It toggles selection and updates the correct scale/color to the icon. On the other hand, a wrapper Composable could be built with a preset of selected/normal attributes and take a boolean to update the same. Again, it‚Äôs a function.@Preview(group = &quot;Icon&quot;)@Composablefun previewIcon() { Surface { var selected by remember { mutableStateOf(false) } AnimatableIcon( imageVector = Icons.Outlined.FavoriteBorder, scale = if (selected) 1.5f else 1f, color = if (selected) COLOR_SELECTED else COLOR_NORMAL, ) { selected = !selected } }}Row designFrom the requirements, the row is responsible for horizontally placing all the icons and update their scale/color based on selected index. It doesn‚Äôt know how the icons react to it. In order to observe whether an icon clicked, it listens to the click and updates the selected index.Apart from the above responsibilities, the row aligns icons as described in the analysis part. To remember which position is selected, it uses a mutable state. This will be updated on icon click and read before setting scale/color for the icons.@Composablefun BottomNavBar2( modifier: Modifier = Modifier, iconSize: Dp = ICON_SIZE, selectedIconScale: Float = 1.5f) { var selectedIndex by remember { mutableStateOf(0) } Row( verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceEvenly, modifier = modifier .fillMaxWidth() .padding(vertical = 8.dp) .height(iconSize.times(selectedIconScale)) ) { for ((index, icon) in navBarItems.withIndex()) { AnimatableIcon( imageVector = icon, scale = if (selectedIndex == index) 1.5f else 1.0f, color = if (selectedIndex == index) COLOR_SELECTED else COLOR_NORMAL, iconSize = ICON_SIZE, ) { selectedIndex = index } } }}Finally, put the bottom nav bar inside a preview and interact with it.@Preview(group = &quot;Main&quot;, name = &quot;Bottom bar - animated&quot;)@Composablefun previewBottomNavBar2() { Surface { BottomNavBar2() }}üìñ Endnote:This navigation bar is a very basic implementation. It doesn‚Äôt even have a callback setup for selection change. And icons are hardcoded. It is a good idea to use the material BottomNavigation as it is well tested and can interact with Snackbar and also has a FAB cradle. Use this as a quickguide on how to keep a view dumb and do state hoisting." }, { "title": "I created few shapes in Jetpack compose / Gist included", "url": "/posts/compose-shapes-gists/", "categories": "Android, Compose", "tags": "android, compose", "date": "2021-07-09 00:00:00 +0530", "snippet": "Sharing few of my jetpack-compose shapes here. Did path tracing and drew path on canvas.HeartüöÄ - GistTagüöÄ - GistPolygonsüöÄ - GistCarüöÄ - Gistüë∑ Tool set Figma for path tracing : steps here SVG path editor Read about polar coordinates here" }, { "title": "Jetpack compose - shape your views", "url": "/posts/compose-shapes/", "categories": "Android, Compose", "tags": "android, compose", "date": "2021-06-23 00:00:00 +0530", "snippet": "Jetpack compose has an elegant way to cut out a Compose view into the desired shape. I‚Äôm covering few shapes that are available in the core compose lib and where do they differ.All the shapes discussed here operate on views corners. So, before going through each, let‚Äôs go through a basic building block called CornerSize.üìè CornerSizeCornerSize is an interface that provides an abstraction to define size in different units. Concrete implementation of this interface converts the given unit to pixels. This pixel value can be used in other parts like Shape for computation.interface CornerSize { fun toPx(shapeSize: Size, density: Density): Float} DpCornerSize - allows defining corner cut in device-independent pixels. (DIP or DP) PxCornerSize - Pixel to pixel conversion is a wrapper implementation to return float which is a pixel. PercentCornerSize - Given a view size and percent, it takes min of height &amp;amp; width and computes the pixel size accordingly. ZeroCornerSize - Object that returns zero pixels.‚Ä¶All the above classes are private and exposed through few convenient functions as seen below. So, be wary of using different units with CornerSize functions.fun CornerSize(size: Dp): CornerSize = DpCornerSize(size)fun CornerSize(size: Float): CornerSize = PxCornerSize(size)fun CornerSize(/*@IntRange(from = 0, to = 100)*/ percent: Int): CornerSize = PercentCornerSize(percent.toFloat())üìê ShapesAll the shapes discussed here has common characteristics listed below: Can cut specific corners or all at once Corner unit size defined in CornerSize. That means it can take the corner size in terms of pixels, dps or percent.1. AbsoluteCutCornerShapeWith AbsoluteCutCornerShape, the resulting shape will have rough corners. It has four member fields (one for each corner). And has few convenience methods to ease out symmetric cuts.class AbsoluteCutCornerShape( topLeft: CornerSize, topRight: CornerSize, bottomRight: CornerSize, bottomLeft: CornerSize): CornerBasedShapeAs you have noticed, the corners are defined in terms of left and right. We‚Äôve moved avay from using left-right and started using start-end long back to support right-to-left(RTL) locales. Why give it up here?Absolute direction is still preferred in few places like cutting top-left of an image. That means, when you wrap a content that is RTL agnostic, use AbsoluteCutCornerShape to cut its corner.Here, listed wrapper functions for Dp unit. Cut out the pixel &amp;amp; percent counterparts for brewity.fun AbsoluteCutCornerShape(size: Dp) = AbsoluteCutCornerShape(CornerSize(size))fun AbsoluteCutCornerShape( topLeft: Dp = 0.dp, topRight: Dp = 0.dp, bottomRight: Dp = 0.dp, bottomLeft: Dp = 0.dp) = AbsoluteCutCornerShape( topLeft = CornerSize(topLeft), topRight = CornerSize(topRight), bottomRight = CornerSize(bottomRight), bottomLeft = CornerSize(bottomLeft))2. CutCornerShapeCutCornerShape is a RTL friendly version of AbsoluteCutCornerShape (not a subclass). This will mirror corner cuts when used in RTL locales. It has the same helper functions defined in the former.class CutCornerShape( topStart: CornerSize, topEnd: CornerSize, bottomEnd: CornerSize, bottomStart: CornerSize) : CornerBasedShape( topStart = topStart, topEnd = topEnd, bottomEnd = bottomEnd, bottomStart = bottomStart)3. AbsoluteRoundedCornerShapeAbsoluteRoundedCornerShape cuts corner with a given radius. So, the cutout shape will have smoother edges. Also, it can cut only specific edges while leaving the others in square cut shape.class AbsoluteRoundedCornerShape( topLeft: CornerSize, topRight: CornerSize, bottomRight: CornerSize, bottomLeft: CornerSize) : CornerBasedShape( topStart = topLeft, topEnd = topRight, bottomEnd = bottomRight, bottomStart = bottomLeft)AbsoluteRoundedCornerShape is RTL agnostic like AbsoluteCutCornerShape. And the helper methods are same as in AbsoluteCutCornerShape.4. RoundedCornerShapeRoundedCornerShape is an RTL-friendly version of AbsoluteRoundedCornerShape. Since we‚Äôve covered enough on other shapes, fast-forwarding to the next shape.class RoundedCornerShape( topStart: CornerSize, topEnd: CornerSize, bottomEnd: CornerSize, bottomStart: CornerSize) : CornerBasedShape( topStart = topStart, topEnd = topEnd, bottomEnd = bottomEnd, bottomStart = bottomStart) 5. CircleShapeCircleShape is an object of RoundedCornerShape that cuts circle. When setting the corner at 50%, it will naturally result in a circle. No need to explain the use-case in applications. Yeah‚Ä¶ circular image view!! val CircleShape = RoundedCornerShape(percentage = 50)‚ÜîÔ∏è RTL - comparisonThis section summarizes the shapes that we discussed above. When a shape has cut only in right or left, we can see the difference between Absolute cuts and RoundedCornerShape / CutCornerShape.So, I have placed four labels stick to the right side of the screen and corner is cut on the left side (or start of the RTL friendly shapes). When the shapes aligned to the right side the labels looks fine. However, when the device preference set to RTL (in developer options), the RTL friendly shapes mirrored themselves while the absolute layouts stick thier noses to the edge.‚Ä¶@Preview(device = Devices.NEXUS_6P, showSystemUi = true)@Preview(device = Devices.NEXUS_6P, locale = &quot;ar&quot;, showSystemUi = true)@Composablefun RTLScreen() { MaterialTheme { Surface { Column(horizontalAlignment = Alignment.End) { SimpleButton( text = &quot;RTL Friendly&quot;, shape = CutCornerShape( topStartPercent = 50, bottomStartPercent = 50 ), ) SimpleButton( text = &quot;RTL Friendly&quot;, shape = RoundedCornerShape( topStartPercent = 50, bottomStartPercent = 50 ), ) SimpleButton( text = &quot;Absolute&quot;, shape = AbsoluteCutCornerShape( topLeftPercent = 50, bottomLeftPercent = 50 ) ) SimpleButton( text = &quot;Absolute&quot;, shape = AbsoluteRoundedCornerShape( topLeftPercent = 50, bottomLeftPercent = 50 ) ) } } }}@Composablefun SimpleButton(text: String, shape: Shape) { Surface( shape = shape, color = color_orange, elevation = 4.dp, modifier = Modifier.padding(top = 20.dp) ) { Text( text = text, modifier = Modifier.padding( start = 24.dp, end = 8.dp, top = 6.dp, bottom = 6.dp ), fontWeight = FontWeight.Bold, color = Color.White ) }}‚úÇÔ∏è Cutting cornersIn any application, there are practical usecase to draw few of these shapes below.1. Tags@Composablefun ContentTag(color: Color, tagName: String) { Surface( shape = AbsoluteCutCornerShape(topLeftPercent = 50, bottomLeftPercent = 50), modifier = Modifier.padding(8.dp) ) { Box( modifier = Modifier .background(color) .padding( start = MaterialTheme.typography.h6.fontSize.value.dp * 1.1f, end = MaterialTheme.typography.h6.fontSize.value.dp / 2, top = 4.dp, bottom = 4.dp, ) ) { Text( text = tagName, color = Color.White, style = MaterialTheme.typography.h6, fontWeight = FontWeight.W300, modifier = Modifier .align(Alignment.Center) ) } }}‚Ä¶2. TearDropA TearDrop shape is basically a rounded rect that bends bottom right at 10% and others with 50%.val TearDropShape = RoundedCornerShape( topStartPercent = 50, topEndPercent = 50, bottomEndPercent = 10, bottomStartPercent = 50)@Composablefun TearDrop(modifier: Modifier = Modifier) { Surface( shape = TearDropShape, color = color_orange, modifier = Modifier .padding(24.dp) .size(60.dp) ) { Box(contentAlignment = Alignment.Center) { Text(text = &quot;7&quot;, fontWeight = FontWeight.ExtraBold, fontSize = 30.sp) } }}3. Message bubblesval IncomingMessage = RoundedCornerShape( topStart = 8.dp, topEnd = 8.dp, bottomEnd = 8.dp, bottomStart = 0.dp)val OutgoingMessage = RoundedCornerShape( topStart = 8.dp, topEnd = 8.dp, bottomEnd = 0.dp, bottomStart = 8.dp)@Composablefun MessageBubble( text: String, isIncoming: Boolean, modifier: Modifier = Modifier,) { Surface( shape = if (isIncoming) IncomingMessage else OutgoingMessage, color = if (isIncoming) color_green else color_blue, modifier = modifier.padding(8.dp) ) { Text( text = text, fontWeight = FontWeight.Light, fontSize = 12.sp, color = Color.White, modifier = Modifier.padding(8.dp) ) }}...MessageBubble(&quot;You have an incoming message&quot;, true)MessageBubble(&quot;Cool!!&quot;, false, modifier = Modifier.align(Alignment.End))...‚Ä¶4. Stadium button@ExperimentalMaterialApi@Composablefun StadiumButton2( text: String, color: Color) { Surface( shape = RoundedCornerShape(percent = 50), color = color, modifier = Modifier.padding(12.dp), onClick = {}, indication = rememberRipple(), elevation = 4.dp ) { Text( text = text, style = MaterialTheme.typography.h6, color = Color.White, modifier = Modifier.padding(horizontal = 16.dp, vertical = 4.dp) ) }}‚Ä¶5. A half baked - House of El@Composablefun SupermanShape(color: Color, size: Dp) { Box(Modifier.rotate(45f)) { Surface( shape = AbsoluteCutCornerShape(topLeftPercent = 50), ) { Box( modifier = Modifier .background(color) .size(size) ) { } } }}‚Ä¶6. Kryptonite@Composablefun Kryptonite(color: Color, size: Size) { Surface( shape = AbsoluteCutCornerShape(percent = 50), modifier = Modifier.padding(8.dp) ) { Box( modifier = Modifier .background(color) .height(size.height.dp) .width(size.width.dp) ) { } }}üõ∏ What‚Äôs next?The above shapes are basic and sharp cut corner or rounded rect. However, when looking at the Tag shape we can see it is not smooth around the edges. Since the shape is basically a path that cuts the rectangle, we can do complex path cuts or polish the above ones. A GenericShape has provision for the same, let‚Äôs cover it in the next article." }, { "title": "Android ‚Äî Implementing LifecycleAwareTimer", "url": "/posts/timer/", "categories": "Android", "tags": "android", "date": "2021-06-18 00:00:00 +0530", "snippet": "Android CountDownTimer is good but it can be better. This article covers few tweaks to the timer and in general how to decouple certain logic from activity.üìö BackgroundCountDownTimer is a convenient API in android when it comes to implementing a timer. However, it lacks few features that have to be filled in by the host Activity /Fragment. Let‚Äôs draft a user story. ‚ùì As a user, I should see a countdown timer that expires at an absolute time.There are multiple ways to achieve this in Android. You can use any of the below APIs. Coroutines-with-delay Thread-handler-sleep CountdownTimerI‚Äôm picking the CountdownTimer, when we reach the end of the article, it‚Äôll be clear why we‚Äôre not using the first two.‚Ä¶üëì Reading between linesThe user story says it should expire at an absolute time. Let‚Äôs assume an offer will expire at 10:00 am. It will expire at 10 whether the activity is running or not. i.e timeout is not bound to the activity or fragment launch time. The timer is merely an attempt to highlight user that he has xx time left till expiry.No need to explain what a timer is ‚Äî for our use-case, it ticks per second.‚Ä¶‚è≤ CountDownTimerCountDownTimer is a simple API that makes use of android‚Äôs Handler.sendMessageDelayed to emit elapsed value in a given interval. This is an abstract class where we have to provide the implementation for the following methods: onTick ‚Äî once every xx-interval onFinish ‚Äî time out object: CountDownTimer(eta, interval) { override fun onTick(millisUntilFinished: Long) {} override fun onFinish() {} }‚Ä¶‚öôÔ∏è ImplementationImplementing it in our activity/fragment is plain and simple. Compute eta and interval, create a timer, start it and update UI on each tick and then finish it when it‚Äôs complete.class OfferActivity: AppCompatActivity() { val expiresAt = // 10 am in millis var timer: CountDownTimer? = null fun onCreate() { startTimer() } private fun startTimer() { // If timer already running cancel it timer?.cancel() val eta = expiresAt - System.currentTimeMillis() val interval = 1000 // every 1 sec timer = object : CountDownTimer(eta, interval) { override fun onTick(millisUntilFinished: Long) { // oversimplified version timerLabel = &quot;${millisUntilFinished/1000} seconds left&quot; } override fun onFinish() { timerLabel = &quot;offer expired&quot; } } timer?.start() } fun onDestroy() { timer?.cancel() }}This is an okayish implementation, but it‚Äôs flawed. Even when the app is in the background, the countdown still runs. So, naturally, like any android developer, we resort to lifecycle methods.fun onPause() { timer?.cancel() }fun onResume() { startTimer() }This will work fine for one activity, but when we need the timer in multiple places, it just clutters the activity with a bunch of lifecycle methods, and missing one of them will end up in a timer that runs in the background or something that doesn‚Äôt resume when activity is foreground. Fortunately, we have a way to remove this clutter with a delegate.‚Ä¶üßπ Decluttering activityLifecycleObserver is an interface from androidx which can register to the activity lifecycle and act on behalf of it. This way, the activity will live clean, yet the concerned class can react to the activity lifecycle. In further sections, we‚Äôll create a wrapper for the countdown timer and register for lifecycle events.Registering to lifecycleclass LifecycleAwareTimer(stopAt: Long, interval: Long)) { @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onResume() {} @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun onPause() {} @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroy() {}}class OfferActivity: AppCompatActivity() { private fun startTimer() { // ... lifecycle.addObserver(LifecycleAwareTimer(stopAt, interval)) }}Now we have a skeleton of LifecycleAwareTimer which is connected to our activity and subscribed to lifecycle events. Next thing is to move our CountDownTimer to the wrapper.‚Ä¶Moving countdown timerCreate a CountDownTimer inside the wrapper and start/cancel it as per the lifecycle callback. Also, consider the case when the timer expires and don‚Äôt start it.class LifecycleAwareTimer(stopAt: Long, interval: Long) { private var timer: CountDownTimer? = null private val expired: Boolean get() = (stopAt - System.currentTimeMillis()) &amp;lt;= 0 fun startTimer() { timer?.cancel() timer = null val eta = stopAt - System.currentTimeMillis() timer = object : CountDownTimer(eta, interval) { override fun onTick(millisUntilFinished: Long) {} override fun onFinish() {} } timer?.start() } fun discardTimer() { timer?.cancel() } @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onResume() { if (expired) { discardTimer() } else { startTimer() } } @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun onPause() { timer?.cancel() } @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroy() { discardTimer() }So far, the timer connects to the activity and internally starts/cancels the countdown. But it doesn‚Äôt deliver results to the host. Let‚Äôs wire it up.‚Ä¶Callbacks to the hostCreate a callback interface to update events from the underlying timer to the host activity and implement the same in Activity.interface TimerCallback: LifecycleOwner { fun onTick(millisUntilFinished: Long) fun onTimeOut()}class OfferActivity : AppCompatActivity(), TimerCallback { fun onTick(millisUntilFinished: Long) { /** seconds ticking **/ } fun onTimeOut() { /** expired**/ }}LifecycleAwareTimer takes in the callback and delivers the result to it. Add the callback to the constructor argument and forward values to the activity.class LifecycleAwareTimer( private val stopAt: Long, private val interval: Long, private val callback: TimerCallback) { fun startTimer() { timer = object : CountDownTimer(eta, interval) { override fun onTick(millisUntilFinished: Long) { callback.onTick(millisUntilFinished) } override fun onFinish() { callback.onTimeOut() } } timer?.start()‚Ä¶Offhooking the observerSince our TimerCallback is also LifecycleOwner, registering/unregistering for lifecycle can be done right within the LifecycleAwareTimer. It registers for a callback when created and removes itself when activity is destroyed or the timer is expired.class LifecycleAwareTimer( private val stopAt: Long, private val interval: Long, private val callback: TimerCallback) { init { callback.lifecycle.addObserver(this) } fun discardTimer() { timer?.cancel() callback.lifecycle.removeObserver(this) } ... timer = object : CountDownTimer { override fun onFinish() { callback.onTimeOut() discardTimer() } } ... @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroy() { discardTimer() } @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onResume() { if (expired) { callback.onTimeOut() discardTimer() } else { // Try to resume timer startTimer() } }Activity side implementationNow pretty much the timer implementation is complete, let‚Äôs have a look at the activity. It holds a timer reference (to avoid duplicate timers) initializes and starts it. Receives callback from onTick &amp;amp; onTimeOut.// Activity private var timer: LifecycleAwareTimer? = null fun startTimer(){ timer?.discardTimer() timer = LifecycleAwareTimer(stopAt, interval, this) timer?.startTimer() } fun onTick(millisUntilFinished: Long) { /** seconds ticking **/ } fun onTimeOut() { /** expired**/ }üìî EndnoteThis might look like an exaggerated version of the timer. But we have a lot of benefits with this approach: Timer depends on LifecycleOwner which means, it can be used with both fragment and activity Timer reacts to lifecycle without explicitly writing much at the host activity/fragment When activity destroyed, the timer kills itself and unregister from lifecycle callbacks Timer pauses when activity hits background and resumes or deliver timeout result when the host hits the surface backWhy didn‚Äôt we use coroutine?The same behavior can be emulated using a coroutine that dispatches to the Main thread. But a disadvantage is we‚Äôll end up owning the elapsed time computation. We still have to use the lifecycle callbacks to manage the coroutine job. And the coroutine itself will contain a while loop with delay and dispatch. When it comes to CountDownTimer, it dispatches messages at a given interval which is organic to the android system.Comple code is available as gist.üßë‚Äçüíª Happy coding üßë‚Äçüíª" }, { "title": "Flow is non-blocking but the collector is not", "url": "/posts/kotlin-flow1/", "categories": "Kotlin", "tags": "kotlin, flow", "date": "2021-06-16 00:00:00 +0530", "snippet": "Flow is an idiomatic way in kotlin to publish sequence of values. While the flow itself suspendable, the collector will block the coroutine from proceeding further. Let‚Äôs see with an example.‚õ≤ FlowsLet‚Äôs create two flows ‚Äî one finite and an infinite one. Both have a suspension point where they free up the thread 2s/1s. The flow builder creates a flow from a suspendable block and emits values with given delay.fun finiteEmissions(): Flow&amp;lt;Int&amp;gt; = flow { repeat(3) { delay(2000) emit(it + 1) }}val random = Random(7659)fun infiniteEmissions() = flow { while (true) { delay(1000) emit(random.nextInt(10, 100)) }}üö∞ Collecting the flowWhen collecting the above flows in the same coroutine, you‚Äôll notice the infiniteEmissions collect statement blocks the next set of statements from running. Whole point of flow is every single element emitted without blocking the current thread. But we‚Äôre not proceeding further in the coroutine. Why?fun main() { runBlocking { infiniteEmissions().collect { logger.debug(it) } logger.debug(&quot;won&#39;t complete&quot;) finiteEmissions().collect { logger.debug(&quot;Finite: $it&quot;) } logger.debug(&quot;completed&quot;) }}10:23:18.018[main] 8010:23:19.019[main] 3610:23:20.020[main] 3010:23:21.021[main] 1110:23:22.022[main] 1010:23:23.023[main] 36&amp;gt;&amp;gt;&amp;gt; goes onReason is, the collect statement itself a suspend function and it will naturally block the current coroutine from within it is called.public suspend inline fun &amp;lt;T&amp;gt; Flow&amp;lt;T&amp;gt;.collect(crossinline action: suspend (value: T) -&amp;gt; Unit): Unit = collect(object : FlowCollector&amp;lt;T&amp;gt; { override suspend fun emit(value: T) = action(value) })So, how do we unblock the rest of the statements or collect the flows in parallel?As usual ‚Äî the launch coroutine builder. Launch starts a new coroutine without blocking the current one. Putting each collect statements in separate launch builder will unblock each other and collect them simultaneuosly.runBlocking { launch { infiniteEmissions() .collect { logger.debug(it) } logger.debug(&quot;won&#39;t complete&quot;) } launch { finiteEmissions().collect { logger.debug(&quot;Finite: $it&quot;) } logger.debug(&quot;completed&quot;) }}10:53:3.003[main] 8010:53:4.004[main] Finite: 110:53:4.004[main] 3610:53:5.005[main] 3010:53:6.006[main] Finite: 210:53:6.006[main] 1110:53:7.007[main] 1010:53:8.008[main] Finite: 310:53:8.008[main] completed10:53:8.008[main] 3610:53:9.009[main] 5510:53:10.010[main] 96&amp;gt;&amp;gt; goes onNow both flows emits values in parallel and notice we‚Äôre staying on same thread[main].üôÖ Cancelling the infinite flowCancelling flow means to cancel the coroutine which collects it. This is applicable for even for a coroutine which doesn‚Äôt contain a flow-collect. launch builder returns a job which can be cancelled. Calling job.cancel() will terminate the underlying coroutine. For our example, to cancel the infinite flow once the second flow complete, do like this.val job = launch { infiniteEmissions() .collect { logger.debug(it) } logger.debug(&quot;won&#39;t complete&quot;)}launch { finiteEmissions().collect { logger.debug(&quot;Finite: $it&quot;) } logger.debug(&quot;completed&quot;) job.cancel()}10:54:10.010[main] 8010:54:11.011[main] Finite: 110:54:11.011[main] 3610:54:12.012[main] 3010:54:13.013[main] Finite: 210:54:13.013[main] 1110:54:14.014[main] 1010:54:15.015[main] Finite: 310:54:15.015[main] completedüç¨ WrapupThis article covered collecting two flows in parallel. Like any other coroutine, launch will start them in parallel (not necessarily in new thread) and cancelled individually. To collect the flows in serial manner, no need for any special care ‚Äî just collecting them from same coroutine would do it.Kotlin playgroundPlay around it here" }, { "title": "GraphQL backend ‚Äî token expiry", "url": "/posts/gql-auth-401/", "categories": "GraphQL", "tags": "graphql, springboot", "date": "2021-06-01 00:00:00 +0530", "snippet": "In the previous post we covered authentication and role management. However, it assumed any invalid session to be a visitor instead of throwing 401‚ÄîUnauthorized client error. This post covers the token expiry aspect of API call.Let‚Äôs start with coding part. Following block diagram explains the interaction between each component. As usual, we‚Äôll build the system bottom-up. üéü Token Service ‚è≤ Token Expiry Strategy üëÆ Request Manager üêû More on error handling üöÄ Run it! üìñ Resourcesüéü Token ServiceTo manage session and expire it, we need meta attributes other than just the token. So, let‚Äôs beef up the token to a data class called SessionToken. This will hold created &amp;amp; last access timestamps in addition to the token itself.data class SessionToken( val token: String, val created: OffsetDateTime, var lastAccess: OffsetDateTime = created)Our token service is a simple repository which abstracts CRUD on token. When user login-register, a new token generated and wrapped in SessionToken. For every web request made, the token updated with last access time. In case user logout or token expired, entry will be deleted.Below is our simple implementation ‚Äî we store our mock tokens as usual to keep our focus on expiry. The created time points to now() i.e we emulate like user logged in at the time of launch.@Serviceclass TokenService { private val store = mutableMapOf&amp;lt;String, SessionToken&amp;gt;() init { store[&quot;token-buyer&quot;] = SessionToken(&quot;token-buyer&quot;, OffsetDateTime.now()) store[&quot;token-seller&quot;] = SessionToken(&quot;token-seller&quot;, OffsetDateTime.now()) } fun createToken() = SessionToken( token = UUID.randomUUID().toString(), created = OffsetDateTime.now() ) fun peekToken(token: String?): SessionToken? = store[token] fun updateLastAccessTime(token: String) { // TODO: Token not found in store - fishy!! store[token]?.lastAccess = OffsetDateTime.now() } fun deleteToken(token: String?) { store.remove(token) }}‚è≤ Token Expiry StrategyWhen it comes to expiry, it‚Äôs always a good practice to abstract out the validation part and create functional interface to carry out the validation. This will help us plug-in different implementations in the system with little config change.This brings us to a functional interface SessionExpiryStrategy which takes a SessionToken validate and return whether it is expired.interface SessionExpiryStrategy { fun isSessionExpired(token: SessionToken): Boolean}An implementation is only good when explained with its implementations. We consider three different strategies for this. Fixed lifespan : Session will expire after 30 days Timeout : If user is not active for 3 minutes ‚Äî logout Extended Lifespan: If user is active during the 30th day, give him grace period in 3 minute window@Component(&quot;fixed_time&quot;)class FixedLifeSpanStrategy : SessionExpiryStrategy { // 30 days fixed lifespan val MAX_DURATION = 30 * 24 * 60 * 60 override fun isSessionExpired(token: SessionToken): Boolean { val durationSinceLogin = ChronoUnit.SECONDS.between( token.created, OffsetDateTime.now() ) return durationSinceLogin &amp;gt; MAX_DURATION }}@Component(&quot;timeout&quot;)class TimeoutExpiryStrategy : SessionExpiryStrategy { // Logout after 3 minutes of inactivity const val MAX_DURATION = 3 * 60 override fun isSessionExpired(token: SessionToken): Boolean { val durationSinceLastAccess = ChronoUnit.SECONDS.between( token.lastAccess, OffsetDateTime.now() ) return durationSinceLastAccess &amp;gt; MAX_DURATION }}@Component(&quot;extended&quot;)class ExtendedLifeSpanStrategy : SessionExpiryStrategy { private val timeoutExpiryStrategy = TimeoutExpiryStrategy() private val fixedLifeSpanStrategy = FixedLifeSpanStrategy() override fun isSessionExpired(token: SessionToken): Boolean { return if (fixedLifeSpanStrategy.isSessionExpired(token)) { // 30 days past, if user is in the mid of something try the timeout // to extend his session timeoutExpiryStrategy.isSessionExpired(token) } else { // 30 days not past yet Let him use the system false } }}Few Usecases:As you can see in ExtendedLifeSpanStrategy, we can mix-match the implementations to tailor user experience. Let‚Äôs say the buyer in our e-commerce website actively purchasing something and just before he makes payment, session expire due to 30 day lifespan ‚Äî It would be frustrating. Three minutes added on each api call will alleviate the expiry.If we want Seller account to logout on 3 minutes inactivity and a fixed timespan for Buyer, it can be achieved by picking strategy ‚Äòper role‚Äô.val strategies = mapOf( BUYER to fixedTimeSpan, SELLER to timeoutStrategy)...strategy[role].isSessionExpired(token)We have a strategy and a tokenservice in place ‚Äî let‚Äôs move on to the final piece where we connect both.üëÆ Request ManagerBefore we move on to the logic, let‚Äôs fix the üêû in user service. From now, it will return null role for unknown/expired tokens. Still, if there is no token present, session will be identified as VISITOR. fun identifyRole(token: String?): Roles? { return if (token == null) Roles.VISITOR else role[token] }In the request manager, wire the expiry strategy as you see fit. We‚Äôll use qualifiers to inject different strategies that we implemented in last section. @Autowired @Qualifier(&quot;timeout&quot;)// @Qualifier(&quot;extended&quot;)// @Qualifier(&quot;fixed_time&quot;) private lateinit var tokenExpiryStrategy: SessionExpiryStrategy // Save the session info per request. Retrieve it throughout the request fun saveSession(request: HttpServletRequest) { // Retrieve auth token from request - if any val token: String? = request.getHeader(HEADER_TOKEN) // Identify role val role = userService.identifyRole(token) if (role == null) { broadcastTokenWipe(token) throw unauthorizedException() } // Handling users that need a session if (role != Roles.VISITOR) { val sessionToken = tokenService.peekToken(token) if (sessionToken == null || tokenExpiryStrategy.isSessionExpired(sessionToken)) { broadcastTokenWipe(token) throw unauthorizedException() } // punch-in to the token service tokenService.updateLastAccessTime(token!!) } request.setAttribute( KEY_SESSION, DummySession( role = role ) ) }Added inline comments for clarity, again a walkthrough here. If role is null, throw exception. If session token is null or expired for non-VISITORs throw exception. In both cases wipe the token off the system.So, what do we throw? ‚Äî 401 response. private fun unauthorizedException() = HttpClientErrorException.create( HttpStatus.UNAUTHORIZED, &quot;&quot;, HttpHeaders.EMPTY, ByteArray(0), Charsets.UTF_8 )If the session is valid, update the last access time in token service to support TimeoutStrategy.üêû More on error handlingIn case, the session is timeout, don‚Äôt let the request proceed further to protect resources. i.e break the chain in request filter.@Componentclass DummyRequestFilter : OncePerRequestFilter() { @Autowired private lateinit var requestManager: DummyRequestManager override fun doFilterInternal( request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain ) { try { // Feed the request to request manager for session preparation requestManager.saveSession(request) // Resume with request filterChain.doFilter(request, response) } catch (e: HttpClientErrorException) { response.sendError(e.rawStatusCode, e.statusText) } }}In dummy request filter, once per request check whether the token is valid. If so, resume the chain, otherwise catch and propogate the 401 error code to the client.üêõ That‚Äôs it üêõüöÄ Run it!curl &#39;http://localhost:8080/graphql&#39; \\ -H &#39;x-auth-token: token-random-one&#39; \\ -H &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{&quot;query&quot;:&quot;mutation {addProduct}&quot;,&quot;variables&quot;:null}&#39; \\ --compressed{&quot;timestamp&quot;:&quot;2021-06-01T18:28:55.325+00:00&quot;,&quot;status&quot;:401,&quot;error&quot;:&quot;Unauthorized&quot;,&quot;path&quot;:&quot;/graphql&quot;}curl &#39;http://localhost:8080/graphql&#39; \\ -H &#39;x-auth-token: token-seller&#39; \\ -H &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{&quot;query&quot;:&quot;mutation {addProduct}&quot;,&quot;variables&quot;:null}&#39; \\ --compressed{&quot;data&quot;:{&quot;addProduct&quot;:&quot;dummy-product-id&quot;}}üìñ Resources Github repo GraphQL playground ‚Äî http://localhost:8080/graphiql" }, { "title": "GraphQL backend ‚Äî authorization &amp; authentication", "url": "/posts/gql-auth/", "categories": "GraphQL", "tags": "graphql, springboot", "date": "2021-05-31 00:00:00 +0530", "snippet": "BackgroundIn any system where users interacting with each other, authorization &amp;amp; authentication are the key elements that controls what each user can do. To read more on authentication and authorization try RBAC. To demonstrate the usecases, I present few roles and resources below. This is an e-commerce website. Role Remarks Visitor There is no session yet, user can enroll in the system to become Buyer/Seller Buyer Buyer can place order and update his address-profile Seller Seller can add product and update order status once Buyer place an order For simplicity resources are just few GraphQL mutations and users are hardcoded in the system. You can get the sample project source at github.Let‚Äôs start with graphql schema and move towards authentication. Background üßë‚Äçüíª Code it Ground preparation Components to know Filters RequestContextHolder RequestManager Aspect [AOP] RequestManager Request filter Custom annotations Aspect üöÄ Run it Why do we need method level control? Future scope üìñ Resourcesüßë‚Äçüíª Code itGround preparationFirst define a schema with few queries that meant for each role. They just return a string when each mutation is invoked. Catch is each user need specific auth token to access the resource. type Mutation { registerUser: String placeOrder: String addProduct: String }And the respective DGSComponent that expose the resource looks like this:@DgsComponentclass DummyResource { @DgsMutation fun registerUser(): String = &quot;dummy-member-id&quot; @DgsMutation fun placeOrder(): String = &quot;dummy-order-id&quot; @DgsMutation fun addProduct(): String = &quot;dummy-product-id&quot;}In a typical system, each of them will need input, since we focus on roles and how do we protect each mutation from other roles, all other parts are omitted for brevity. We expect the system to throw error when authentication fails. Below is the DummyUserService class where system identifies user role given an auth-token.@Serviceclass DummyUserService { val sessions = mapOf( &quot;token-buyer&quot; to Roles.BUYER, &quot;token-seller&quot; to Roles.SELLER ) fun identifyRole(token: String?): Roles { return sessions[token] ?: Roles.VISITOR }}enum class Roles { VISITOR, BUYER, SELLER}Above wraps up the overall, setup for roles and resources. Let‚Äôs wire up authentication.Components to knowWe‚Äôll use following components to set up authentication. They are born of springboot &amp;amp; aspectj and not specific to graphql. So, even RestController can benefit using the below ones. Oneliner on each piece before start implementing them. How do they interact is illustrated in below diagram.Components in orange will be created by us. Green one is provided by springboot. And the blue wrapper is generated by aspectj for us.FiltersFilters are the requst interceptors. They can process any incoming servlet request before it reaches the resolver (in our case the mutation). We‚Äôll use OncePerRequestFilter to augment our incoming request with Role related information.RequestContextHolderRequestContextHolder can hold session related information (user id, token, role) for a servlet request. However, we own the logic to build a session context. At any point of time, this can be accessed within the system to identify session.RequestManagerThis is created by us to wrap RequestContextHolder and provide nice interface to other components in play. Business logic to build a session context is done here.Aspect [AOP]Aspect oriented programming is a programming paradigm where any component can be augmented to provide common functionalities, so that each controller (mutation) doesn‚Äôt have to hold any repeating business logic (authentication). This is achieved by creating proxy classes around the target class. Head over to wiki to know more about this.That covers each component and it‚Äôs role in authentication. Let‚Äôs code to have further clarity. I‚Äôll build bottom up to so that we‚Äôll know the dependency between each.RequestManagerRequst manager reads header from incoming request and store it to RequestContextHolder. It uses UserService created in Ground preparation section. It also hosts few helper methods to ease up session data retrieval in latter parts. Code should be self-explanatory with inline comments.@Componentclass DummyRequestManager { @Autowired private lateinit var userService: DummyUserService // Save the session info per request. Retrieve it throughout the request fun saveSession(request: HttpServletRequest) { // Retrieve auth token from request - if any val token: String? = request.getHeader(HEADER_TOKEN) // Identify role val role = userService.identifyRole(token) // attribute the request with session. This will be available throughout the session request.setAttribute( KEY_SESSION, DummySession( role = role ) ) } // A non-null guaranteed session. Everyone has a role here. fun getSession(): DummySession { val session = RequestContextHolder .getRequestAttributes()!!.getAttribute(KEY_SESSION, RequestAttributes.SCOPE_REQUEST) return session as DummySession } /** * Convenience method to retrieve role */ fun getUserRole(): Roles = getSession().role companion object { private const val KEY_SESSION = &quot;userSession&quot; private const val HEADER_TOKEN = &quot;x-auth-token&quot; }}data class DummySession( val role: Roles)Request filterRequest filters are the interceptors for any request. Logging and session creation are the common usecase for this component. Let‚Äôs create a DummyRequestFilter and invoke request manager to create session./** * Interceptor that executed once per http request */@Componentclass DummyRequestFilter : OncePerRequestFilter() { @Autowired private lateinit var requestManager: DummyRequestManager override fun doFilterInternal( request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain ) { // Feed the request to request manager for session preparation requestManager.saveSession(request) // Resume with request filterChain.doFilter(request, response) }}Custom annotationsWith above two pieces in place, we identified user role per request. Next is to retrict access for each mutation. Let‚Äôs create few annotations for each role.@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class BuyerOnly@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class SellerOnly@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class VisitorOnlyMarking the territory for each user.File: &quot;DummyResource.kt&quot;@DgsComponentclass DummyResource { @VisitorOnly @DgsMutation fun registerUser(): String = &quot;dummy-member-id&quot; @BuyerOnly @DgsMutation fun placeOrder(): String = &quot;dummy-order-id&quot; @SellerOnly @DgsMutation fun addProduct(): String = &quot;dummy-product-id&quot;}AspectWe have session and resource marked for each role. All that‚Äôs left is to read the annotation and role and authenticate requests. For this purpose, we have Aspects ‚Äî aspects can run before-after-even around a pointcut. Here, pointcut refers to our mutation method ‚Äî the safety net logic that we execute before mutation is called advice. Together they‚Äôre called aspect. So, our final piece ‚Äúthe aspect‚Äù is here.@Component@Aspectclass DummyAspect { @Autowired private lateinit var requestManager: DummyRequestManager @Before(&quot;@annotation(SellerOnly)&quot;) fun restrictSellerOnly(joinPoint: JoinPoint) { val role = requestManager.getUserRole() if (role != Roles.SELLER) { throw GraphQLException(&quot;This operation is specific to Seller accounts&quot;) } } @Before(&quot;@annotation(BuyerOnly)&quot;) fun restrictBuyerOnly(joinPoint: JoinPoint) { val role = requestManager.getUserRole() if (role != Roles.BUYER) { throw GraphQLException(&quot;This operation is specific to Buyer accounts&quot;) } } @Before(&quot;@annotation(VisitorOnly)&quot;) fun restrictVisitorOnly(joinPoint: JoinPoint) { val role = requestManager.getUserRole() if (role != Roles.BUYER) { throw GraphQLException(&quot;Please logout from existing session&quot;) } }}That‚Äôs it.üöÄ Run itTry running the mutation in curl or graphiQL playground [http://localhost:8080/graphiql].// Seller adds product succussfullycurl &#39;http://localhost:8080/graphql&#39; \\ -H &#39;x-auth-token: token-seller&#39; \\ -H &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{&quot;query&quot;:&quot;mutation { addProduct }&quot;,&quot;variables&quot;:null}&#39; \\ --compressed{&quot;data&quot;:{&quot;addProduct&quot;:&quot;dummy-product-id&quot;}}// Buyer cannot add product curl &#39;http://localhost:8080/graphql&#39; \\ -H &#39;x-auth-token: token-buyer&#39; \\ -H &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{&quot;query&quot;:&quot;mutation {\\n \\n addProduct\\n \\n}&quot;,&quot;variables&quot;:null}&#39; \\ --compressed{ &quot;errors&quot;: [ { &quot;message&quot;: &quot;This operation is specific to Seller accounts&quot;, &quot;locations&quot;: [], &quot;extensions&quot;: { &quot;errorType&quot;: &quot;UNKNOWN&quot; } } ], &quot;data&quot;: { &quot;addProduct&quot;: null }}Why do we need method level control?Following query is possible with graphql.mutation { addProduct placeOrder }### header&quot;x-auth-token&quot;:&quot;token-seller&quot;In a single graphQL http-request you can stack up multiple operations. In such cases, only one operation fails while the other execute successfully. Pretty cool right üòé?.{ &quot;errors&quot;: [ { &quot;message&quot;: &quot;This operation is specific to Buyer accounts&quot;, &quot;locations&quot;: [], &quot;extensions&quot;: { &quot;errorType&quot;: &quot;UNKNOWN&quot; } } ], &quot;data&quot;: { &quot;addProduct&quot;: &quot;dummy-product-id&quot;, &quot;placeOrder&quot;: null }}Future scopeWith this scaffold we can build resources with granular control. With simple annotations added to each method, it is possible to restrict nested objects without modifying much to the business logic in resolvers.For this example, we took Role in focus. Let‚Äôs say I need to create a resource specific to a user, like an address. I don‚Äôt have to (shouldn‚Äôt) pass in user-id in the input. It is cross verified against the token and available in session. A full context like user‚Äôs client/locale etc. will be availble to tailor perfect response.In a reallife system, the userservice would be table query or federated service provider. For performance, the session information should be cached and remote calls must be avoided to get bit of performance boost.üìñ Resources Github repo Aspect oriented programming Role Based Access Control" }, { "title": "LeetCode ‚Äî Median of Two Sorted Arrays", "url": "/posts/L4-median/", "categories": "Coding, LeetCode", "tags": "coding", "date": "2021-05-28 00:00:00 +0530", "snippet": "Problem definition is here. Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Sample inputs What is median? Draft Hypothesis Iteration Picking elements Handling odd/even number of elements SolutionSample inputsInput: nums1 = [1,3], nums2 = [2]Output: 2.00000Explanation: merged array = [1,2,3] and median is 2.Input: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.What is median?In a given sorted data set, median is the middle element. It is not neccessarily the mean/average.[2, 2, 3, 4, 10]‚á® mean = (2+2+3+4+10)/5 = 4.2‚á® median 3DraftFew things to note, before solving the problem: Input arrays are already sorted. That means, we don‚Äôt have to sort the resulting array if we pick the elements in correct order. Result asking for median of the resulting array, not the array itself. So, we don‚Äôt have to allocate a new arrray at all. From the inputs, if total number of elements is odd, we‚Äôll pick a single element. Otherwise, average of the two elements in the middle.HypothesisIterationSince we‚Äôre looking for median, we don‚Äôt have to iterate all the way upto m + n. Here, m and n are size of each array. For odd number of elements, we pick one median and it‚Äôs two for even numbers. So, how far do we iterate? m+n median index vis. 3 1 [0, 1, 2] 4 1,2 [0, 1, 2, 3] 5 2 [0, 1, 2, 3, 4] 6 2,3 [0, 1, 2, 3, 4, 5] Notice that I mentioned median index and index starts with zero. So, when I mention first index, it is the second element in the result array.Can we formulate the number here?4 ‚á® 4/2 = 2 [m1 = 1, m2 = 2]5 ‚á® 5/2 = 2 [m2 = 2]For a given total(m+n), we‚Äôll iterate up to (m+n)/2 index. If the total is odd, pick only m2, otherwise average of m1 + m2. So, last two iterations matters most.Picking elementsIn order to fill elements in result array, we have to pick the least element of the two arrays.Input:[1, 4][2, 9]0 --&amp;gt; [1]1 --&amp;gt; [1,2]2 --&amp;gt; [1,2,4]3 --&amp;gt; [1,2,4,9] // we don&#39;t move this far ‚Äî iteration stops at index 2What if same number present in two arrays? ü§î It doesn‚Äôt matter. Both will be placed adjacent in array anyway, and we‚Äôre just focusing on the value.So, we need to keep two pointers(i, j) for both arrays to pick element in head. What do we pick?if (nums1[i] &amp;lt; nums2[j]) { m2 = nums2[i] i++} else { m2 = nums2[j] j++}There is a special case as well. What if one of the arrays ran out of elements?. In such case, we have to pick element from the other array and move pointer accordingly.// num1 reached its endif (num1.size == i) { m2 = nums2[j] j++}Handling odd/even number of elementsThrough each iteration, we update medians m1 &amp;amp; m2. At the end, last two picks (or just one) considered for median. Values always stored in m2 and on each iteration, m1 will cache the previous value of m2. Things will be much clear with actual solution below.SolutionPutting all the above together, we have the solution here. Again, I added comments inline.fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double { // Pointers to array var i = 0 var j = 0 // Identified medians var m1 = 0 var m2 = 0 // iterate upto - (m+n)/2 for (k in 0..(nums1.size+nums2.size)/2) { // caching previous value m1 = m2 if (i == nums1.size) { // First array ran out of elements, pick second m2 = nums2[j] j++ } else if (j == nums2.size) { // Second array ran out of elements, pick first m2 = nums1[i] i++ } else if (nums1[i] &amp;lt; nums2[j]) { // First array element is lower m2 = nums1[i] i++ } else { // Second array element is lower m2 = nums2[j] j++ } } // For even numbers avg of m1 &amp;amp; m2, m2 otherwise return if ((nums1.size+nums2.size)%2 == 0) { (m1 + m2) / 2.0 } else m2.toDouble() }üßë‚Äçüíªüßë‚Äçüíª peace üßë‚Äçüíªüßë‚Äçüíª" }, { "title": "Kotlin solution for the longest Substring Without Repeating Characters", "url": "/posts/length-of-substring/", "categories": "Coding, LeetCode", "tags": "coding", "date": "2021-05-27 00:00:00 +0530", "snippet": "For problem definition head over to leetcode problem#3.For a given string, we need to find the length of the longest substring. Listed few sample input and outputs below for understanding.Max() = 0Max(a) = 1Max(aa) = 1Max(ab) = 2Max(abca) = 3Max(abcdefghijk) = 11Max(abccabcde) = 5Max(abccabdefghabcababcab) = 8Emphasized on length as we don‚Äôt need the actual substring itself but the length. So, let‚Äôs jump into implementation.Brute forceThe brute force approach would be to pick a start and end index within the string and compare each character against themselves and have a global variable to track the max length. This solution involves three loops for picking start‚Äîend indexes and comparing characters. Let‚Äôs not consider this solution and move on to the algorithimic approach.Solution ‚Äî Sliding windowFor a subset problem, one of the approaches to take in is a Sliding window. Sliding window restricts the looping to subset of elements. By maintaining certain global pointers, it avoids revisiting the same node multiple times. We can restate our problem statment in different way. We need the length of the substring, in other words, difference between two indicesWith above in mind, we setup our window in following manner. Our end index (i) will increase in linear manner in the range of (0, n-1) both inclusive. With end fixed, we update the start index based on last occurance. Since we need only the length, difference between the indices will do the trick.Instruction set: If an element is already present, move the start pointer if needed Compute the length between start and end indices and max length For each element, update a lookup table with the latest encounter indexI‚Äôve dropped the solution below and walkthrough follows. fun lengthOfLongestSubstring(s: String): Int { // Sliding window start pointer var start = 0 // Result var max = 0 // Occurance map var occ = mutableMapOf&amp;lt;Char, Int&amp;gt;() for ((i, c) in s.withIndex()) { if (occ.containsKey(c)) { // Found a clash, move the start pointer // next to the previous occurance if applicable val seekPoint = occ[c]!! + 1 start = Math.max(seekPoint, start) } val length = i - start + 1 max = Math.max(length, max) // Update the map with latest occurance // when clash happen next time, use this index occ[c] = i } return max }WalkthroughLet‚Äôs have a walkthorugh on iteration.Given abcamnijabxyzzz, max-substring is mnijabxyz # start end char subsequence length 0 0 0 a a 1 1 0 1 b ab 2 2 0 2 c abc 3 3 1 3 a* bca 3 4 1 4 m bcam 4 5 1 5 n bcamn 5 6 1 6 i bcamni 6 7 1 7 j bcamnij 7 8 4 8 a* mnija 5 9 4 9 b* mnijab 6 10 4 10 x mnijabx 7 11 4 11 y mnijabxy 8 12 4 12 z mnijabxyz 9 13 13 13 z* z 1 14 14 14 z* z 1 0-2 ‚Äî Each element is scanned, added to lookup map. Since there is no clash, start index is unchanged.3 ‚Äî From lookup we come to know a was encountered in 0th index. So, start is adjusted to (0+1)4-7 ‚Äî There is no clash, start is still at 1. At 7th iteration, you can see bcamnij is the current substring. i.e first a is excluded, new a is present in the substring.8 ‚Äî From lookup, we found a was last encountered in 3rd index. Notice [a, 0] updated to [a, 3] during last encounter at 3. This is crucial because, if we keep the first encountered index in lookup, it will include duplicates. Now we update start to (3+1).9 ‚Äî At 9, we found b is present in 1. But we won‚Äôt update the start with (1 + 1), since we‚Äôre way past 1st index. So we retain the start at 4. To verify the uniqueness, mnijab is the current substring. If at all, we‚Äôve updated our start to 2 we‚Äôll have camnijab ‚Äî here two as present.10-12 ‚Äî Through these iterations, we add character by character to the substring. Keeping the start index at 4.13 ‚Äî z is identified as duplicate. So index adjusted to previous encounter + 1 ‚á® 12 + 1. The substring contain single character. The second z.14 ‚Äî Same as iteration 13.Note: apart from the window movement, the lookup and max length is updated in each step. Since it is an obvious step to the algorithm, I skipped in walkthrough. Though I printed the substring in the table, it is not necessary for our final result.‚Ä¶With a lookup map and sliding window, we reduced the time complexity to O(n). Space complexity would be O(m), where m is unique charsets.‚Ä¶üë®‚Äçüíª happy coding üë©‚Äçüíª" }, { "title": "GraphQL backend ‚Äî pagination &amp; filters", "url": "/posts/gql-filters-pagination/", "categories": "GraphQL", "tags": "graphql, springboot, kotlin", "date": "2021-05-25 00:00:00 +0530", "snippet": "BackgroundPagination and filters are the much needed components when it comes to listing. They not only narrow down the list for the user, but improves load time and save user from scanning through lots of pages. Overall content engagement will improve when the list is on point and incrementally loaded in small chunks. This post covers setup &amp;amp; implementation of pagination in springboot-graphql environment.Sample project used in this post is available in Github. Project overall architucture is in below diagram. Background Project overview Project setup Database ORM ‚Äî JPA repository GraphQL setup Pagination and Filter setup What paginates the data source? Schema Data fetchers Run it SummaryProject overviewBasic project setup involves a database, ORM and graphql to compose the response. H2 is a lightweight relational database that is a goto option for casual projects. ORM ‚Äî [Object‚Äìrelational mapping] is a technique that connects object to the database. With ORM, database can be accessed without the need of writing any query. JPA ‚Äî (Java Persistence API) is used in this project for accessing the database. Netflix-DGS framework is used for GraphQL setup ‚Äî it is a superset of java-graphql implementation.Project setupDatabaseH2 database requires way less setup compared to others. H2 is added as a runtime dependency to the application and will be availble to use when the application starts. Following dependency enables the h2-driver to connect with our database.dependencies { ... runtimeOnly(&quot;com.h2database:h2&quot;)}Now that our app knows the H2 driver, it needs the database url and credentials to connect with it. Adding the following properties tells springboot to use h2 driver and use the given credentials.//File:&quot;application.properties&quot;# Driverspring.datasource.driverClassName=org.h2.Driverspring.datasource.url=jdbc:h2:file:~/be/db/expenses;AUTO_SERVER=truespring.datasource.username=saspring.datasource.password=passwordspring.jpa.database-platform=org.hibernate.dialect.H2Dialect# Table creation from entity classesspring.jpa.hibernate.ddl-auto=update# H2 console# http://localhost:8080/h2-console/spring.h2.console.enabled=trueThe driver section is straightforward where the app reads db url and credentials. H2 database can be used as an in-memory datasource as well as it can persist the data to a .db file. For the url ~/be/db/expenses a local file expenses.mv.db created in local storage.In the second section, spring.jpa.hibernate.ddl-auto property tells springboot to create tables out of the ORM Entity classes. For this example entity class called Expense is considered. Few annotations added to the class / fields to make up table and it‚Äôs columns.@Entity(name = &quot;expenses&quot;)data class Expense( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Int? = 0, @Column(nullable = false, name = &quot;amount&quot;) val amount: Int? = null, @Column(name = &quot;remarks&quot;, nullable = false) val remarks: String? = null, @Column(name = &quot;is_income&quot;, nullable = false) val isIncome: Boolean? = false)The H2 Console section enables the web interface to the h2 database. It will be available at http://localhost:8080/h2-console/ once the application started. With current setup, it should show the expenses table with no records in it.H2 console web interfaceORM ‚Äî JPA repositoryJPA can be added to the project with following gradle dependency.//File: build.gradle.kts// JPAimplementation(&quot;org.springframework.boot:spring-boot-starter-data-jpa:2.5.0&quot;)In springboot, repository is an interface makes a skeleton for entity and it‚Äôs primary key. The repository for the expenses entity is a simple one line interface. Based on the need, complex queries can be declared in the repository.interface ExpenseRepository : JpaRepository&amp;lt;Expense, Int&amp;gt;On top of common CRUD operations, JpaRepository covers sort/filter/pagination usecases as well. To give an idea on what are all the operations that we get from JPA, pasted the original JpaRepository interface below.public interface JpaRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt; { List&amp;lt;T&amp;gt; findAll(); List&amp;lt;T&amp;gt; findAll(Sort sort); List&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; ids); &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entities); void flush(); &amp;lt;S extends T&amp;gt; S saveAndFlush(S entity); void deleteInBatch(Iterable&amp;lt;T&amp;gt; entities); void deleteAllInBatch(); T getOne(ID id); &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example); &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Sort sort);}GraphQL setupFor GraphQL, Netflix DGS is used in this project, for two main reasons. It generates models out of schema &amp;amp; it registers fetchers and data loaders with few annotations. Following changes required in build file to add dgs to the project.plugins { // Code generation plugin id(&quot;com.netflix.dgs.codegen&quot;) version &quot;4.6.4&quot;}tasks.withType&amp;lt;com.netflix.graphql.dgs.codegen.gradle.GenerateJavaTask&amp;gt; { packageName = &quot;com.ex2.gql.dgmodels&quot; schemaPaths = mutableListOf(&quot;${projectDir}/src/main/resources/schema&quot;)}dependencies { implementation(&quot;com.netflix.graphql.dgs:graphql-dgs-spring-boot-starter:3.12.1&quot;)}Here, the com.netflix.dgs.codegen plugin reads schema file placed in resource directory and generate classes. com.netflix.graphql.dgs:graphql-dgs-spring-boot-starter takes care of connecting the data fetchers(REST controller equivalent) &amp;amp; loaders (layers in between fetcher and repository) to the main application.Pagination and Filter setupWhat paginates the data source?The key player in this post is the following method in JPARepository. Although this post drives towards GraphQL, any form of API can make use of the core logic in below method.//File:&quot;QueryByExampleExecutor.java&quot; &amp;lt;S extends T&amp;gt; Page&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Pageable pageable);This method takes in a probe object to filter the data source with and directives for paging and sorting. This probe object can be the one extended from our entity or entity object itself. Any field that is not required for filtering, can be set to null.findAll delivers result in a wrapper class called Page, which contains the subset (a chunk of items) and blueprint of over all data set (total number of pages). This total pages will be used at the client end to stop fetching further from the list.SchemaIn GraphQL schema drives the rest of the project, the surface setup and then the underlying machanics are built. DGS framework takes care of code generation when the schema file is present in right resource folder.For this post, expected model is a page of expenses which provides meta info regarding the total number of pages and current page number. The schema will look like this.input ExpenseFilter { isIncome: Boolean}type Expense { id: ID remarks: String amount: Int isIncome: Boolean}type ExpensePage { list: [Expense] totalPages: Int currentPage: Int}type Query { fetchExpenses(filter: ExpenseFilter, pageNumber: Int, pageSize: Int) : ExpensePage}Here, Expense denotes single item in expenses list, ExpensePage is a wrapper that holds list of expenses and page info. Provided these types, dgs-codegn plugin will generate classes based on type and field names. These classes will be used in later sections to connect with ORM.ExpenseFilter is a class that represents filter for expense entity, more on this covered in data fetchers section. fetchExpenses is a query operation for GraphQL, it takes filter, pageNumber and pageSize as arguments and returns ExpensePage.// Generated ‚Äî Expense Page classpublic data class ExpensePage( @JsonProperty(&quot;list&quot;) public val list: List&amp;lt;Expense?&amp;gt;? = null, @JsonProperty(&quot;totalPages&quot;) public val totalPages: Int? = null, @JsonProperty(&quot;currentPage&quot;) public val currentPage: Int? = null) { public companion object}Data fetchersA DataFetcher is where GraphQL compose the response from entity. Query mentioned in Query#fetchExpenses is materialized here to fetch data from the database. These classes must be marked as DgsComponent to be considered as a graphql component. It can contain number of graphQL operations annotated matching the signature in schema. To connect with database, ExpenseRepository reference is created to use inside the data fetcher.@DgsComponentclass ExpenseDataFetcher { @Autowired private lateinit var expenseRepository: ExpenseRepositoryfetchExpenses operation can be hooked to a method as in below. Arguments are appropriately annotated with field names from the schema. Input and output classes are the DGS generated ones. @DgsData(parentType = &quot;Query&quot;, field = &quot;expenses&quot;) fun expenses( @InputArgument(&quot;filter&quot;) filter: ExpenseFilter?, @InputArgument(&quot;pageNumber&quot;) pageNumber: Int, @InputArgument(&quot;pageSize&quot;) pageSize: Int ): ExpensePage {Filter for JPA can be provided by creating an example object with matching values and passes to the expenseRepository.findAll function. If null field passed to the example object, it will not be considered for filtering.The findAll function also takes in a PageRequest object as second argument to provide pagination. This page request requires pageNumber, size and an optional Sort parameter. val probe = Expense( id = null, remarks = null, isIncome = filter?.isIncome, amount = null ) val example = Example.of(probe) val pageRequest = PageRequest.of( pageNumber, pageSize, Sort.by( Sort.Order.desc(&quot;id&quot;) ) ) val result: Page&amp;lt;Expense&amp;gt; = expenseRepository.findAll(example, pageRequest)So far, the result is of type Page&amp;lt;Expense&amp;gt;, this is close to the ExpensePage defined in schema but not exactly the same. So, the last part is to convert JPAEntity to GraphQL ‚Äî Object. For this matter, a utility class called ExpenseGEMapper is used, it basically reads each field from Jpa model and assigns it to graphql model. Implementation can be found below. val list = result.content.map { ExpenseGEMapper.toGraph(it) } return ExpensePage( list = list, totalPages = result.totalPages, currentPage = pageNumber ) }//File:&quot;ExpenseGEMapper.kt&quot;import com.ex2.gql.expense.jpa.entities.Expense as EExpenseimport com.ex2.gql.dgmodels.types.Expense as GExpenseobject ExpenseGEMapper : GraphEntityMapper&amp;lt;GExpense, EExpense&amp;gt; { override fun toGraph(e: EExpense): GExpense { return GExpense( id = e.id?.toString(), remarks = e.remarks, acNumber = e.acNumber, isIncome = e.isIncome, amount = e.amount, account = null ) } override fun toEntity(g: GExpense): EExpense { return EExpense( id = g.id?.toInt(), remarks = g.remarks, acNumber = g.acNumber, isIncome = g.isIncome, amount = g.amount ) }}With above function, the pagination &amp;amp; filter is complete. The expense data fetcher class is available here for reference.Run itGraphiQL playground is available in http://localhost:8080/graphiql to try the queries. Given the filter/page details, it returs the list, and page number to query further in the list. Clients can query until totalPages.query Expense { fetchExpenses(filter: {isIncome: false}, pageSize: 10, pageNumber: 0) { list { id remarks amount } totalPages currentPage }}### response{ &quot;data&quot;: { &quot;expenses&quot;: { &quot;list&quot;: [ { &quot;id&quot;: &quot;295&quot;, &quot;remarks&quot;: &quot;Book MK&quot;, &quot;amount&quot;: 90 } ... { &quot;id&quot;: &quot;286&quot;, &quot;remarks&quot;: &quot;Book MK&quot;, &quot;amount&quot;: 90 } ], &quot;totalPages&quot;: 27, &quot;currentPage&quot;: 0 } }}SummaryA graphQL schema, ORM and data fetcher work together to make an API paginated. As number of filter fields increase, GraphQL will scale gracefully with very little code change where only the ExpenseFilter to Example class conversion is affected." }, { "title": "GraphQL backend ‚Äî data loaders", "url": "/posts/gql-data-loaders/", "categories": "GraphQL", "tags": "graphql, springboot, kotlin", "date": "2021-05-21 00:00:00 +0530", "snippet": "In the previous post, I created a FatExpense object and added manual checks to avoid fetching Account entity. If we‚Äôre scanning the selection manually and write our own check, what‚Äôs the role of GraphQL here?Actually GraphQL handles all this, I just wanted show the problem of doing it manually. Let‚Äôs see what is what and what does each component do.Here we‚Äôre looking at two problems We have to create Entity to match our schema model [FatExpense] For each Expense ‚Äî a query made to Account data source [i.e N+1 problem]Let me explain what is N+1 problem in breif and we can jump to the implementaion. The N+1 problem üë®‚Äçüíª Code it Preparing your datasource Create a batch loader Throw away the fat-object Tell DGS how to fetch Account üöÄ Launch it How does it scale? Endnote ResourcesThe N+1 problemN+1 is when you make N queries from the outer object to get inner object. So the number of total queries made is 1 (outer object) + N (one query per row). In our example, we make 1 query to fetch Expense list and N queries to fill in account inside each expense. As nesting increase, it affects performance of the system.Our mock data set is designed in a way that, all the expenses shared between three accounts. We consider our solution is a win when we achieve max 3 calls to the accounts source instead of 100 (one per expense). val accounts = mutableListOf( Account(acNumber = 1, nickName = &quot;Wallet&quot;, balance = 100000), Account(acNumber = 2, nickName = &quot;Axis&quot;, balance = 240000), Account(acNumber = 3, nickName = &quot;ICICI&quot;, balance = 28000), ) val expenses = mutableListOf&amp;lt;Expense&amp;gt;() private val random = Random(10000) private fun randomExpense() = random.nextInt(from = 100, until = 800) init { for (i in 1..100) { expenses.add( Expense( id = i, amount = randomExpense().absoluteValue, remarks = &quot;Transaction $i&quot;, isIncome = (i % 2 == 0), acNumber = (i % 3 + 1) ) ) } }üë®‚Äçüíª Code itWe need three components to decouple our entities and fix N+1 problem. DataSource that supports batch fetch A DataLoader DataFetcher that carries the contextPreparing your datasourceTo alleviate the N fetches, what we can do is to find unique set of account numbers and then fetch them in one go. To achieve it, our data source has to support batch fetch of accounts as unlike our get acccount by id which deliver a single row of account. Let‚Äôs add it. fun getAccounts(acNumbers: List&amp;lt;Int&amp;gt;): List&amp;lt;Account&amp;gt; { println(&quot;DAO.getAccounts - $acNumbers&quot;) return accounts.filter { acNumbers.contains(it.acNumber) } }Create a batch loaderA batch loader is a component in GraphQL that extracts unique set of keys from series of requests and make a batch request to the data source. This way the resulting query is optimized to contain unique key/ids and only one fetch made to the data source.@DgsDataLoader(name = &quot;AccountNumberToAccount&quot;)class AccountsDataLoader : BatchLoader&amp;lt;Int, Account&amp;gt; { override fun load(keys: MutableList&amp;lt;Int&amp;gt;?) : CompletionStage&amp;lt;MutableList&amp;lt;Account&amp;gt;&amp;gt; { return CompletableFuture.supplyAsync { return@supplyAsync DataSource.DAO .getAccounts(keys ?: emptyList()) .toMutableList() } }}In the above code block, we register AccountsDataLoader to DGS registry under the alias of AccountNumberToAccount. This name acts like an identifier in DgsDataFetchingEnvironment to obtain the DataLoader.It is a parameterized class, that maps Int (Account number) to Account entity and we have a load function that takes in set of unique account numbers and convert them to Future, that will be exucuted in batches. This Future nature of content fetch encourages GraphQLs async nature of resolving a query. Why it is a CompletableFuture instead of upfront fetch?Assume each request from server to database takes 10ms. 100 sequntial calls to the database will endup in 1000 ms latency for a single field. Making the loader asynchronous enables us to fill in other fields for the response dynamically and deliver the result faster.Throw away the fat-objectIf we create a wrapper entity for each nested query, we‚Äôll endup creating a bunch of entities (or an obese one). DGS got it covered for us. Just delete the FatExpense and update the ExpenseDataFetcher with the original entity.+++ b/src/main/kotlin/com/ex2/gql/expense/fetchers/ExpenseDataFetcher.kt @DgsData(parentType = &quot;Query&quot;, field = &quot;expenses&quot;)- fun expenses(dfe: DgsDataFetchingEnvironment): List&amp;lt;FatExpense&amp;gt; {- return DataSource.expenses.map {- val result = FatExpense(- id = it.id,- amount = it.amount,- remarks = it.remarks,- isIncome = it.isIncome,- account = null- )-- val loadAccount = dfe.field- .selectionSet- .selections- .any { field -&amp;gt; (field as? graphql.language.Field)?.name == &quot;account&quot; }-- if (loadAccount) {- result.account = DataSource.DAO.getAccount(it.acNumber)- }- result- }+ fun expenses(dfe: DgsDataFetchingEnvironment): List&amp;lt;Expense&amp;gt; {+ return DataSource.expenses }Tell DGS how to fetch AccountNow that we deleted the FatExpense class, we have to wire up the connection between Expense and Account. We do it in Account Data fetcher. First revisit the schema before do the linking.type Expense { ... account: Account}We have a type called Expense and it holds a field account of type Account. Inside DGSData annotation, mention the parentType and which field in the schema it resolves. And pass down the dfe (DgsDataFetchingEnvironment) context for fetching Account. @DgsData(parentType = &quot;Expense&quot;, field = &quot;account&quot;) fun getAccount(dfe: DgsDataFetchingEnvironment): CompletableFuture&amp;lt;Account&amp;gt; { val dataLoader: DataLoader&amp;lt;Int, Account&amp;gt; = dfe.getDataLoader(AccountsDataLoader::class.java) val source = dfe.getSource&amp;lt;Expense&amp;gt;() val acNumber = source.acNumber return dataLoader.load(acNumber) } dfe passes context information such as source from which this request originated and selection (fields required in account entity) to the called function.Inside the function body, from DgsDataFetchingEnvironment we get a loader for AccountsDataLoader. It is important to use dfe to create the loader, as it sets scope for the data loader. This helps to reuse the same loader for each Expense that tries to load account information. dfe carries the callers scope that we can get using getSource. From there, we can retrieve the account number and queue account fetch request. Just leaving a note here, the parentTypeThat‚Äôs it, we don‚Äôt have to make any check on selection or create an entity that matches the schema or manually club the N+1 queries. A data loader and a DgsData annotation will handle scoping ‚Äî de-duplicating &amp;amp; delivering result in async manner.üöÄ Launch itLaunch http://localhost:8080/graphiql in browser and feed the below query. And check the DataSource.DAO#getAccounts logs.query Expense { expenses { id remarks amount account { acNumber nickName } }}### LogsDAO.getAccounts - [2, 3, 1]We have a single fetch request made to the account data source with a batch of account numbers.How does it scale?Let‚Äôs say we have another data type called Transfer with from and to ‚Äî both fields of type Account. All we need to do is to declare two functions for from and to fields. Rest of the DataLoader and DataSource changes can be reused. @DgsData(parentType = &quot;Transfer&quot;, field = &quot;from&quot;) ... @DgsData(parentType = &quot;Transfer&quot;, field = &quot;to&quot;) ...EndnoteWith three components added to the codebase (two of them reusable), we have a decoupled yet context aware data loading in our system. Here we explored BatchLoader ‚Äî one of the commonly used loader. There are other types such as BatchLoaderWithContext, MappedBatchLoader and MappedBatchLoaderWithContext each tailored to address specific usecase. Make use of them and enjoy GraphQLing your backend.DataLoader is part of java-graphql project and not specific to DGS. Role of DGS here is to provide a solid registry for data fetchers &amp;amp; loaders.Resources Commit: Migrating to DataLoader Spring-expenses Repository java-dataloader" }, { "title": "GraphQL backend ‚Äî nested objects", "url": "/posts/gql-nested-objects/", "categories": "GraphQL", "tags": "graphql, springboot, kotlin", "date": "2021-05-20 00:00:00 +0530", "snippet": "A nested object is like a Matryoshka doll where one object placed inside another and you can choose to not open the next level ‚Äî a perfect usecase to demonstrate the power of GraphQL.In this post we‚Äôll see how nested objects can be read from GraphQL server and how the mapping works here. For this purpose, I‚Äôm bringing in a new entity ‚Äî called Account. For any expense or income, an account will be mapped to it. It is a Many (Expense)s to One (Account) mapping. This opens possibilities to few queries that involve both entities. Get expense details ‚Äî Include account info For a given account, list expenses Delete account and related expensesWe‚Äôll focus on the first one. Enough with the introduction, let‚Äôs jump to the coding part. Account entity setup Foreign key mapping Nested object lookup On demand data loading Account entity setupOur account entity is a simple model which has three fields as in below block. data class Account( val acNumber: Int, val nickName: String, val balance: Int )Complete Account Entity, Schema and Fetcher changes are present in this single commit. Since we already covered CRUD on single entity, I‚Äôm fast-forwarding here. I left some sample queries on Account entity to play in GraphiQL (http://localhost:8080/graphiql).mutation CreateAccount { updateAccount(account: {acNumber: 5, nickName: &quot;Retirement&quot;, balance: 10000}) { acNumber nickName balance }}query AllAccounts { accounts { acNumber nickName balance }}mutation DeleteAccount { deleteAccount(acNumber: 1)}So far our account and expense entities don‚Äôt know each other. Let‚Äôs introduce them. We have three stages in it, I made separate commits for each stage. Foreign key mapping &amp;amp; migration?! Nested object lookup On demand data loadingForeign key mappingBefore linking the entities let‚Äôs understand how both of them are connected. In this case, given an expense it is connected to an account. For any account, there could be multiple expenses. That means a many-to-one relationship. By convension we represent this as a foreign key in Expense table.Same can be represented in our expense entity as follows. data class Expense(@@ -11,4 +12,5 @@ data class Expense( val amount: Int, val remarks: String, val isIncome: Boolean,+ val acNumber: Int )If you‚Äôve noticed, the acNumber is a non-nullable int field in expense. That means we have to ensure the same on Expense creation part. So our expense input and schema gets few changes as well.## src/main/resources/schema/schema.graphqls input ExpenseInput { remarks: String amount: Int+ acNumber: Int }## src/main/kotlin/com/ex2/gql/expense/data/models/ExpenseInput.kt data class ExpenseInput( val amount: Int, val remarks: String,+ val acNumber: Int )We can reflect the same in create query, and include the acNumber to create an expense with mapping. That‚Äôs about the creation part ‚Äî now all the new expenses will be linked to an account. Note that, we haven‚Äôt added any validation whether the account is present in the accounts list. Our focus is on read part, above creation flow is un-avoidable.mutation CreateExpense { createExpense(data: { remarks:&quot;new expnse&quot;, amount: 122, isIncome: false, acNumber: 1}) { id remarks } }Try the above mutation in GraphiQL to create expense. Next part is fetching it.Nested object lookupThough, the object is represented as FK in our entity, what client really need is a fat-object that includes account in it. So, let‚Äôs start edit the schema and bubble up the changes to the fetcher.+++ b/src/main/resources/schema/schema.graphqlstype Expense { remarks: String amount: Int isIncome: Boolean+ account: Account }We‚Äôve added the account field in expense, but the fetcher doesn‚Äôt know it yet. It still returns the expense entity which has acNumber as forign key. To expand the same, create an intermediatery object that can directly map to the schema ‚Äî lack of names calling it a FatExpense. This replaces the FK with actual object.data class FatExpense( val id: Int, val amount: Int, val remarks: String, val isIncome: Boolean, val account: Account)Next, in the fetcher make changes to intialize the account field. This involves querying the accounts list per expense. So, the DAO ‚Äî and fetcher changed as follows. // DAO fun getAccount(acNumber: Int): Account { println(&quot;Accounts.getAccount &amp;gt; $acNumber&quot;) return accounts.find { it.acNumber == acNumber }!! } // Fetcher fun expenses(): List&amp;lt;FatExpense&amp;gt; { return DataSource.expenses.map { FatExpense( id = it.id, amount = it.amount, remarks = it.remarks, isIncome = it.isIncome, account = DataSource.DAO.getAccount(it.acNumber) ) } }This should do it, head over to the GraphiQL and run a nested query. A simple query &amp;amp; response will look like this.query NestedExpense { expenses { remarks amount account { acNumber } }}### Response{ &quot;data&quot;: { &quot;expenses&quot;: [ { &quot;remarks&quot;: &quot;new expense&quot;, &quot;amount&quot;: 122, &quot;account&quot;: { &quot;acNumber&quot;: &quot;1&quot; } }, }}Nice! Is it over yet? NoLet‚Äôs say I need only the amount and remark in my list. Following query should get it to me.query SimpleExpense { expenses { remarks amount }}## Response{ &quot;data&quot;: { &quot;expenses&quot;: [ { &quot;remarks&quot;: &quot;new expense&quot;, &quot;amount&quot;: 122 } }}It still works as expected. What‚Äôs wrong with it?Checking the network logs, we can find the SimpleExpense query still probes the accounts list even though we havn‚Äôt mentioned it in the selection [fields that we request from client]. This is bad for resource consumption. How do we fix it? Is GraphQL/DGS equipped with anything to help with it?On demand data loadingDGS can tell a fetcher what are all the fields that is present in the request. Same is available in the form of special parameter called DgsDataFetchingEnvironment. After adding it to our query and debug the paramter for selection, I found the selection three levels down. @DgsQuery fun expenses(dfe: DgsDataFetchingEnvironment): List&amp;lt;FatExpense&amp;gt; { // Should load account?? val loadAccount = dfe.field .selectionSet .selections .any { field -&amp;gt; (field as? graphql.language.Field)?.name == &quot;account&quot; } }selections is a tree like structure that will expand as query‚Äôs depth. For this use-case, we‚Äôre checking the field name account. Refer below screenshot for how selection is structured.Now we know when to query for account, to implement it in fetcher FatExpense#account is made nullable ‚Äî var, and on-demand assigned inside fetcher.+++ b/src/main/kotlin/com/ex2/gql/expense/data/models/ExpenseInput.kt@@ -22,5 +22,5 @@ data class FatExpense(- val account: Account+ var account: Account?+++ b/src/main/kotlin/com/ex2/gql/expense/fetchers/ExpenseDataFetcher.kt val expense = FatExpense( ... ...- account = DataSource.DAO.getAccount(it.acNumber)+ account = null )+ val loadAccount = dfe.field... + if (loadAccount) {+ expense.account = DataSource.DAO.getAccount(it.acNumber)+ }Same query from above section won‚Äôt invoke account query now. This is a first level of optimization over the nested graph ‚Äî Nodes are fetched on-demand. However, there is still room for improvement. Look at the NestedExpense usecase, we‚Äôre fetching the Account‚Ä¶ that‚Äôs expected. Problem is we‚Äôre fetching the same account for multiple accounts. Spoiler alert ‚Äî modern dbs caching this kind of query results to mitigate the performance impact. That doesn‚Äôt mean we should code it this way.Let‚Äôs catch up later.üöÄ Happy coding üöÄ" }, { "title": "Quickguide to intellij live template", "url": "/posts/live-template/", "categories": "Tools", "tags": "tools, android, kotlin", "date": "2021-05-19 00:00:00 +0530", "snippet": "LiveTemplate is a feature in Intellij based IDEs where you can expand a code snippet by typing an abbreviation and the IDE guide your cursor through the parts that need your attention (a variable name).Intellij has a whole set of live templates at your disposal. Few of them you might‚Äôve been using it in day to day basis. Check this list blow. sout logi soutf soutm appNs psvm and goes on‚Ä¶ If you haven‚Äôt used them before, for items 1-4 open a kotlin file ‚á® type the abbreviation and press tab to expand.üíÅ‚Äç‚ôÇÔ∏è You can write one too, it just takes 5 minutes and knowing what is what. Let‚Äôs jump to it. Know your template Cursor context Placing cursor in template What is LiveData? Placeholders Know your templateTemplate is special kind of macro that allows you to enter your input in between / place cursor for you. It is located in Preferences ‚á® Editor ‚á® Live templates section. Let‚Äôs have a look at soutf and analyze what cooks the live template.// soutf : Prints current class and function name to System.outprintln(&quot;$CLASS$.$METHOD$&quot;)It‚Äôs just a one-liner where class and method wrapped inside $. IDE reads thesee variables and fill in when expanding it.Cursor contextOne major thing to design a better template is Cursor context. It tells the IDE, when is a Live template is applicable. Expanding a kotlin code inside a xml file is totally useless.For soutf, the context is set to work inside Kotlin files, and it can expand inside a function. Try to expand it outside a function. Check the below templates to know various contexts. abbreviation scope main top-level sout statement fun0 class ifn expression The Best way understand the scope is to expand all these templates in their destined place in code. That‚Äôs all about the context, on to the fun part where we edit the sout template.Placing cursor in templateThe sout template is great, it autofills classname and function name for us. But it places cursor outside the quotes after expanding it. Let‚Äôs fix it. Add an $END$ to the template and try it now.println(&quot;$CLASS$.$METHOD$ $END$&quot;)That‚Äôs a bit about scopes and cursor. Let‚Äôs create our live template for LiveData.What is LiveData? An android class that connects UI to the Presenter/VieweModel.If you‚Äôre not familiar with LiveData, think of it as an Observable. Any consumer class can attach to it and get updates when the underlying value change. It has two variants, LiveData(observe only model) and MutableLiveData(Superset of LiveData ‚Äî where you can publish values).Let me draw out the target code and inline why each line is needed. // A mutable backing property which is set to private. private val _email = MutableLiveData&amp;lt;String&amp;gt;() // Frontface to field, the observers will be able to read // but, cannot modify val emailLiveData : LiveData&amp;lt;String&amp;gt; = _email // Syntactic sugar ‚Äî to validate the data in later part // of the application ‚Äî use this private val email: String? get() = emailLiveData.value // A setter method that updates our mutable property // write code to trigger validation in here. This is why // we don&#39;t expose the mutable version of livedata outside. fun updateEmail(value: String?) { _email.value = value // start your validation flow here }Scanning though the live template window in IDE, you might‚Äôve already figured out how to duplicate/create new live template. Ours will be called ld. I‚Äôll use the same name going further. Notice that ld is scoped to Kotlin ‚Äî Class.Live Template for LiveDataPlaceholdersIn sout, we didn‚Äôt need user input on anything as cursor context can give us the function and class names. That‚Äôs not the case with ld (LD), here we need two inputs from the user. Property name $PROP_NAME$ and Type $PROP_TYPE$ ‚Äî rest can be filled by live template.private val _$PROP_NAME$ = MutableLiveData&amp;lt;$PROP_TYPE$&amp;gt;()val $PROP_NAME$LiveData : LiveData&amp;lt;$PROP_TYPE$&amp;gt; = _$PROP_NAME$private val $PROP_NAME$: $PROP_TYPE$? get() = $PROP_NAME$LiveData.valuefun update$PROP_NAME_IN_FUNCTION$(value: $PROP_TYPE$?) { _$PROP_NAME$.value = value}By mentioning these placeholders in different places, we tell the IDE to fill-in the variable wherever we it inside the template. So, when you type email for the PROP_NAME, it is filled in for LiveData, MutableLiveData, in the field so on. Same for PROP_TYPE.We have another placeholder called PROP_NAME_IN_FUNCTION, which is a capitalized version of our PROP_NAME. So, that‚Äôs about template content, now we have to tell the IDE, what each placeholder is.Click on Edit Variables and input the values as in below table. Name Expression PROP_NAME ¬† PROP_TYPE className() PROP_NAME_IN_FUNCTION capitalize(PROP_NAME) The property name is left to our choice, there is not much IDE can do about it. When filling in PROP_TYPE, IDE will suggest classes. And PROP_NAME_IN_FUNCTION is a derived property that capitalizes the PROP_NAME(email ‚á® Email). Now we have a live template setup for future use. Create as many as you want and focus on what matters the most. Happy coding ‚å®Ô∏è." }, { "title": "A perfect setup for my Github pages project", "url": "/posts/code-editor/", "categories": "Tools", "tags": "tools, markdown, blog", "date": "2021-05-18 00:00:00 +0530", "snippet": "I hosted my blog in github pages and one thing was constantly bugging me. How can I efficiently get more with writing way less? And focus on the content rather than things like image hosting or previewing it. To start with blogging, lets checkout my setup. Treat your blog like repository. Write like a coder ‚Äî commit like a coder. Make tools work for you.If you‚Äôre not familiar with Jackyll &amp;amp; github pages, there is a nice article from smashing magazine to quick setup your gihub page. My Focus VS Code Language tools Distraction free mode PasteImage ‚Äî plugin Inbuilt console VCS control Recommended extensions Noteworthy mention ‚Äî Typora ‚Äî my previous editor EndnoteMy Focus Distraction free Markdown editing Easy editing of blog configuration [tags, config.yaml, frontmatter etc] Previewing the blog as it is before going live Seamless integration to host my image in the repo VCS controlVS CodeMy choice of editor is VSCode. I made this decision purely hoping, I‚Äôll find a plugin for anything. I wasn‚Äôt wrong, I did find very nice plugins on my way, it made easier to edit-commit-preview the content.Language toolsOnce I started content writing, I realized my language could be java/kotlin or javascript. But definetly not English. So, I installed this nice plugin called LanguageTool, to help me with grammatical mistakes. It struggles to find errors inside markdown format, yet it feels good to fix things before going live.Press Option + Return or Alt + Enter as you do for code errors and apply quick fix.Distraction free modeVSCode zen mode is the best when I focus on content editing. Once I enter distraction free mode, all the other panels gone and editor line is highlighted. Still, I get inputs from Language Tools.PasteImage ‚Äî pluginOne of my concern when editing markdown is to include images / gifs in my ReadME file. With image file in my hand, it is not a problem, I can move the file to asset directory and give relative path. But for simple usecase like attaching an image from my clipboard buffer, there is no elegant solution in VSCode ‚Äî unless you install PasteImage plugin.Copy a screenshot or image then inside the editor invoke command panel and type PasteImage. Now you have your image inserted next to the MD file and the path is linked. But, for a github page you need assets in a different location. So, I pasted my configuration snippet for pasteImage here.//File:&quot;.vscode/settings.json&quot;{ &quot;pasteImage.path&quot;: &quot;${projectRoot}/assets/img&quot;, &quot;pasteImage.insertPattern&quot;: &quot;![](/assets/img/${imageFileName})&quot;}When you insert an image, file saved to /assets/img directory and proper relative path added to markdown.![](/assets/img/2021-05-18-12-30-35.png)This might look trivial that, you commit image to your github instead of uploading to an image-host provider like imgur. In a long run having control over your image will come in handy. Your repo is your blog is a cool thing.Inbuilt consoleSince our page is powered by jackyll, it is important to see the page in localhost for any visual artifacts. Though this can be easily done from an external terminal, I prefer to run it inside the IDE.bundle exec jekyll serve## For larger sites ‚Äî if anything breaks, do a clean bundle.bundle exec jekyll serve --incrementalStart your jackyll build with above command and visit your page in browser at http://localhost:4000/. This way I know how my page will look when going live. Any unsupported liquid tag or ui breakage can be identified in early stages of content writing.VCS controlI can do commit ‚Äî revert ‚Äî stage content right inside the IDE and push it to repo. This is something useful for a commit triggered publishing system like GitHub pages.Recommended extensionsI can right click on an extension and add it to recommendation. A pretty cool feature to consider when you can take all the tools with your blog when moving to a different machine. Listed my favorite extensions for this project below.{ &quot;recommendations&quot;: [ &quot;mushan.vscode-paste-image&quot;, &quot;dracula-theme.theme-dracula&quot;, &quot;adamvoss.vscode-languagetool-en&quot;, &quot;brunnerh.insert-unicode&quot; ]}Noteworthy mention ‚Äî Typora ‚Äî my previous editorTypora is one of the best markdown editors out there for markdown editing. It has a very powerful markdwon rendering engine that updates content inline, so you don‚Äôt have to worry about how the content will look after you type it. I tried blogging using typora for a while and moved on to VSCode for few reasons In the blog, the spacing I see in typora will be different Lack of language tool [or I haven‚Äôt figured out that part yet!] Editing the config yaml and going through the directory structure is bit offI still use typora to take notes and making documentation that will go out as PDF. If your focus is on content alone and don‚Äôt mind copy-pasting the markdown to your repo, üõ∏ go for it.EndnoteAbove is purely my opinion about the tools. I choose VSCode since, I don‚Äôt have to leave the IDE to spell check / update the image. All in one place will let me focus on content. It is future proof as VSCode already has bunch of add-ons and I hope they‚Äôll add more to the line.Since some add-ons are made for available for other editors like Atom, there is no vendor lock here like Typora. Granular control over the IDE experience is an advantage. If any better extension released for markdown, I can use it in conjunction with Zenmode or any other tooling that I mentioned above. Also, keybindings can be created for extensions, it‚Äôs just awesome.‚á®" }, { "title": "GraphQL backend ‚Äî update &amp; delete", "url": "/posts/gql-delete-update/", "categories": "GraphQL", "tags": "graphql, springboot, kotlin", "date": "2021-05-18 00:00:00 +0530", "snippet": "In the first installment, I covered create and read operations to the Expense entity. Now let‚Äôs add few more operations ‚á® update and delete queries.Entire source code is available in github. For intial setup read this post. As Netflix ‚Äî DGS propose, start with schema and then edit the fetcher.‚å®Ô∏è Code itOpen schema.json and add these mutations. They‚Äôre not treated differently from the createExpense mutation. Whatever write operation, it is treated as mutation. Let‚Äôs update the mutations.//File: &quot;schema.json&quot;type Mutation { createExpense(data: ExpenseInput) : Expense deleteExpense(id: ID): Boolean updateExpense(expense: UpdatedExpense): Expense}input UpdatedExpense { id: ID remarks: String amount: Int isIncome: Boolean}Corresponding query fetchers are pretty straightforward. // Deletes an expense if any and return true or false based on it. @DgsMutation fun deleteExpense(id: Int): Boolean { return expenses.removeIf { it.id == id } } @DgsMutation fun updateExpense(expense: Expense): Expense { // This is an upsert operation. If id already present in list // overwrite it / otherwise insert at 0th index val index = expenses.indexOfFirst { it.id == expense.id } if (index != -1) { expenses[index] = expense } else { expenses.add(0, expense) } return expense }Notice that we have separate input type defined in schema for updateExpense mutation while the mutation reuses the same type?This is because, GrpahQL expects separate entities created for input and data models. Wheras in the dataftcher, only constraint is to match the data model to schema.üöÄ Run itI‚Äôve listed few queries that you can run in our server. Run ./gradlew bootRun to start the server Open http://localhost:8080/graphiql in the browser and try these queries# Creates an expense with this inputmutation CreateExpense { createExpense(data: {remarks: &quot;From GraphiQL&quot;, amount: 100, isIncome: true}) { id remarks amount isIncome }}# Lists all the expensesquery ListExpenses { expenses { id remarks amount isIncome }}# Deleting an expensemutation DeleteItem { deleted: deleteExpense(id : 1)}# Update / insert an expense based on idmutation UpdateItem { updateExpense(expense: {id: 2, remarks: &quot;From GraphiQL&quot;, amount: 100, isIncome: true} ) { id remarks amount isIncome }}It is rather simple change that we did, and now we have completed CRUD operations on a simple data set. Changes are available in a single commit here.EndnoteThis is a short post, it just gives you an idea on how delete / update operations can be written using GraphQL. This whole article has only one take, that we don‚Äôt have to create UpdatedExpense class in data fetcher to run the mutation. Any data model that matches the field type and argument name, will do just fine.In future articles in the series, I‚Äôll explore nested objects and how effective GraphQL is when it comes to resource consumption." }, { "title": "GraphQL - simple backend server - SpringBoot application", "url": "/posts/gql-simple-backend/", "categories": "GraphQL", "tags": "graphql, springboot, kotlin, beginners", "date": "2021-05-17 00:00:00 +0530", "snippet": "In this post, I‚Äôll cover how to create a simple GraphQL server with Springboot and Netflix DGS. DGS is chosen because you start with GraphQL schema and then build server side logic around it. Prerequisite Initial setup Know the project structure How to run the project? Coding Netflix DGS framework setup GraphQL schema setup Mapping java model to the schema GraphiQL playground Adding a mutation Accessing the GraphQL endpoint in client apps and Insomnia / Postman Source code EndnotePrerequisite Intellij IDEA GraphQL JS plugin Kotlin fill class plugin - optional Initial setupTo start with SpringBoot https://start.spring.io/ has set of templatesFor springboot project, headover to https://start.spring.io/ and add Spring Web dependency. Select ‚Äî Kotlin, jar, Java 11 as project base in lefet pane. Hit Generate button and extract the downloaded zip to a project folder.Know the project structureOur application is a single module project in the below tree format. Now it has bare minimum classes to just start the server.‚îú‚îÄbuild.gradle.kts‚îú‚îÄgradle‚îÇ¬† ‚îî‚îÄ wrapper‚îÇ¬† ‚îú‚îÄ gradle-wrapper.jar‚îÇ¬† ‚îî‚îÄ gradle-wrapper.properties‚îú‚îÄgradlew‚îú‚îÄgradlew.bat‚îú‚îÄsettings.gradle.kts‚îî‚îÄsrc ‚îú‚îÄ main ‚îÇ¬†¬† ‚îú‚îÄ kotlin ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ com.ex2.gql.expense //package ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ ExpenseApplication.kt ‚îÇ¬†¬† ‚îî‚îÄ resources ‚îÇ¬†¬† ‚îú‚îÄ application.properties ‚îÇ¬†¬† ‚îú‚îÄ static ‚îÇ¬†¬† ‚îî‚îÄ templates ‚îî‚îÄ test ‚îî‚îÄ kotlin ‚îî‚îÄ com.ex2.gql.expense ‚îî‚îÄ ExpenseApplicationTests.ktfig. Springboot - initial project structureKnow about few files from the project structure. build.gralde.kts - is where we add our project dependencies [database / logger / graphql] ExpenseApplication.kt is the starting point of our application. Java main method is placed here Files and folders of name gradle* are present here to build our app resources directory is where we place out graphql schemas src/main/kotlin is we actually code our business logicHow to run the project?Start terminal at the project root and run../gradlew bootRun‚Äî or ‚ÄîFor development, we‚Äôll use Intellij. So, select the bootRun gradle task in the gradle tool window and start.On both cases, gradle wrapper will download all the dependencies (including the gradle distribution itself), and then start the application.CodingNetflix DGS framework setupNetflix has released the dgs framework as open source on 2020. It powers the netflix API layer for over an year now. DGS plugin is available in mavencentral for us to use - Add the below dependency to your project.// https://mvnrepository.com/artifact/com.netflix.graphql.dgs/graphql-dgs-spring-boot-starter implementation(&quot;com.netflix.graphql.dgs:graphql-dgs-spring-boot-starter:3.12.1&quot;)This plugin provides set of annotations that will connect our data fetchers / queries to our main application ExpenseApplication and generates graphiql playground for us to play around with our data.GraphQL schema setupschema is the contract between client and server. DGS is a schema first framework. i.e we define a schema and DGS generate model classes for us. Let‚Äôs start by creating a schema file in resource directory.‚îî‚îÄresources ‚îú‚îÄ application.properties ‚îú‚îÄ schema ‚îÇ¬†¬† ‚îî‚îÄ schema.graphqls ‚îú‚îÄ static ‚îî‚îÄ templatesCreate file schema.graphqls in the resources/schema directory. And define an operation and a data model as below.type Query { expenses : [Expense]}type Expense { id: ID remarks: String amount: Int isIncome: Boolean}Mapping java model to the schemaTo get basic understanding on how model/entity is connected to the schema, Let‚Äôs create a data class for Expense and corresponding fetcher. Fetchers are the helper classes that acts as an adapter between schema and data model.//File:&quot;ExpenseDataFetcher.kt&quot;@DgsComponentclass ExpenseDataFetcher { private val expenses = mutableListOf( Expense(id = 1, amount = 10, remarks = &quot;Expense 1&quot;, isIncome = false), Expense(id = 2, amount = 120, remarks = &quot;Expense 2&quot;, isIncome = false), Expense(id = 3, amount = 110, remarks = &quot;Income 3&quot;, isIncome = false), ) @DgsQuery fun expenses(): List&amp;lt;Expense&amp;gt; { return expenses } data class Expense( val id: Int, val amount: Int, val remarks: String, val isIncome: Boolean )}Tips: To fill in the data class, you can use the Fill data class plugin. It can generate default values for all the parameters. Inside the Expenses block invoke suggestions by Alt(Option) + Return(Enter) key.That‚Äôs it!!Now we have a working setup of a GraphQL query to play with. Annotations DgsQuery and DgsComponent will connect our model to the schema and register our component with main application.GraphiQL playgroundNow run the application and visit http://localhost:8080/graphiql. You should see the GraphiQL page ‚Äî A visual tool where you construct your queries and verify the fetcher.query MyQuery { expenses { amount remarks }}Query call to the serverAdding a mutationTo add a mutation, head over to the schema file and add input type and a mutation for expense.type Mutation { createExpense(data: ExpenseInput) : Expense}input ExpenseInput { remarks: String amount: Int isIncome: Boolean}Add a bit of code to insert an element into the list. Give matching names and a method to create field [auto generated id]. And an annotation to connect function to the mutation query.//File:&quot;ExpenseDataFetcher.kt&quot; private val random = Random(10000) private fun randomInt() = random.nextInt() @DgsMutation fun createExpense(data: ExpenseInput): Expense { val expense = Expense( id = randomInt(), amount = data.amount, remarks = data.remarks, isIncome = data.isIncome, ) expenses.add(0, expense) return expense } data class ExpenseInput( val amount: Int, val remarks: String, val isIncome: Boolean )Now try the mutation in GraphiQL playground. You should see the new Expense object is returned. Verify the entry added to the list by again running MyQuery in the playground.mutation MyMutation { createExpense(data: {remarks: &quot;From GraphiQL&quot;, amount: 100, isIncome: true}) { id remarks amount isIncome }}Mutation call to the server‚Ä¶Accessing the GraphQL endpoint in client apps and Insomnia / PostmanIf you‚Äôre fond of a REST/GraphQL client or to use the API in your client already, use the following endpoint.// Endpoint for Clienthttp://localhost:8080/graphql// GraphiQL playground http://localhost:8080/graphiql Note there is no i in endpoint.GraphQL query in InsomniaSource codeEntire source code is available in Github.EndnoteThis the the bare minimum setup to make Create / Read requests to the backend using GraphQL. It is a steep learning curve to write queries for nested objects and connecting to a persistent database. Also there are other components available in DGS framework for codegen and custom scalars. I‚Äôll explore and add each usecase to this series." }, { "title": "Get productive with GraphQL ‚Äî Type Adapters", "url": "/posts/graphql-date-conversion/", "categories": "Android, Apollo‚ÄîGraphQL", "tags": "android, kotlin, graphql", "date": "2021-05-16 00:00:00 +0530", "snippet": "One of the demanding features in any serializer-deserializer is the ability to convert data to user defined format. GraphQL is smart enough to generate classes &amp;amp; parsers for your primitive / nested objects. However, there are cases where GQL cannot determine what to do with a field. In such cases, we can lend a hand and get type safe fields in return.Usecase taken for this post is timestamp ‚Äì It‚Äôs string by transmission but we need it as Date object. We‚Äôll peek though the schema &amp;amp; query files that drives the codegen and get it to bend for our need.I covered the code generation part for clarity before the implementation. For the implementation, skip to the how to section. Pre-requisite Data types in GraphQL Peek to the schema How codegen handles custom scalars? How do I translate timestamp to Date object? 1. Choosing concrete type for custom scalar - [threetenbp lib] 2. Code-gen changes - Apollo compile time setup to map timestamp 3. Apollo runtime setup for parsing date Gist EndnotePre-requisiteBasic understanding of what is GraphQL. Having a working GraphQL android codebase is even better. Read this for setting up the ApolloClient and how to write query for a given schema. Also, Apollo has a quick guide to get started with GraphQL.Data types in GraphQLA GraphQL query is made of nodes and leaves (referred as scalars) too often. There are default scalars defined in system as such, Int, Float, String &amp;amp; Boolean. However like in our case, backend can mark fields as custom scalars to expect client side processing.// File: &quot;queries.graphql&quot;expenses { ## node id amount remarks is_income created_at ## Custom scalar}Here in the above query we have created_at maked with timestamptz. Let‚Äôs scan through schema.json for how it looks.Peek to the schema// Example - default scalar{ &quot;args&quot;: [], &quot;isDeprecated&quot;: false, &quot;deprecationReason&quot;: null, &quot;name&quot;: &quot;remarks&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;NON_NULL&quot;, &quot;name&quot;: null, &quot;ofType&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;String&quot;, // Known date type &quot;ofType&quot;: null } }, &quot;description&quot;: &quot;Where the money went&quot;},// Example - custom scalar{ &quot;name&quot;: &quot;created_at&quot;, &quot;type&quot;: { &quot;kind&quot;: &quot;NON_NULL&quot;, &quot;name&quot;: null, &quot;ofType&quot;: { &quot;kind&quot;: &quot;SCALAR&quot;, &quot;name&quot;: &quot;timestamptz&quot;, &quot;ofType&quot;: null } }, &quot;description&quot;: &quot;Created timestamp&quot;},As we can see, the timestamp cannot fall into a known scalar platform specific implementation for below reasons The plugin just don‚Äôt know what‚Äôs the date format is. There is no single format universally agreed for DateTime communication. Moreover, it can be just date or time. So it‚Äôs up to the dev to decide on this. Plenty of options out there when it comes to Date and time. Based on personal preference, one can go for Jave Date, Calendar, DateTime, Joda(don‚Äôt use this), three-ten-bp or kotlinx datetime Api.How codegen handles custom scalars?Apollo generates an enum to book-keep the custom scalars. It maps the scalar name to corresponding (fully qualified) type name known in the platform. Without any type adapters, it look like this.// File: &quot;CustomTypes.kt&quot;import com.apollographql.apollo.api.ScalarTypeimport kotlin.Stringenum class CustomType : ScalarType { TIMESTAMPTZ { override fun typeName(): String = &quot;timestamptz&quot; override fun className(): String = &quot;kotlin.Any&quot; }}Generated class for Expense node look like this. Currently the created_at is of type Any, waiting for us to make it concrete. Scaning through the the file, you‚Äôll find where it is serialized and deserialized.// File: &quot;Expenses.kt&quot;data class Expense( val __typename: String = &quot;expenses&quot;, val id: Int, val amount: Int, val remarks: String, val is_income: Boolean, val created_at: Any ) { fun marshaller(): ResponseFieldMarshaller = ResponseFieldMarshaller.invoke { writer -&amp;gt; ... writer.writeString(RESPONSE_FIELDS[3], this@Expense.remarks) ... // Serializing cusom fields here writer.writeCustom(RESPONSE_FIELDS[5] as ResponseField.CustomTypeField, this@Expense.created_at) } companion object { private val RESPONSE_FIELDS: Array&amp;lt;ResponseField&amp;gt; = arrayOf( ... ResponseField.forString(&quot;remarks&quot;, &quot;remarks&quot;, null, false, null), ... // Definition of custom response field ResponseField.forCustomType(&quot;created_at&quot;, &quot;created_at&quot;, null, false, CustomType.TIMESTAMPTZ, null) ) operator fun invoke(reader: ResponseReader): Expense = reader.run { ... val remarks = readString(RESPONSE_FIELDS[3])!! val is_income = readBoolean(RESPONSE_FIELDS[4])!! // De-Serializing the field here val created_at = readCustomType&amp;lt;Any&amp;gt;(RESPONSE_FIELDS[5] as ResponseField.CustomTypeField)!! Expense( ... ) } ... } }Though, on surface created_on marked as Any field, under the hood it leaves markers indicating this type can be changed to some concrete type.Let‚Äôs convert the timestampz.How do I translate timestamp to Date object? To convert the timestampz to Date, we need both compiler and apollo client to work together. Solution consist of three parts. Choosing concrete type for custom scalar Mapping it in code-gen Attaching adapter to the apollo client 1. Choosing concrete type for custom scalar - [threetenbp lib]My choice of DateTime library here is threetenbp. This ports Java SE 8 LocalDateTime classes to java 6 and 7. My initial feasibility check with kotlinx-datetime results didn‚Äôt look so good as custom formatting of date time is not supported yet.Add this gradle dependency to your app module.// File: &quot;app/build.gradle&quot;// https://mvnrepository.com/artifact/org.threeten/threetenbpimplementation &quot;org.threeten:threetenbp:1.5.1&quot;2. Code-gen changes - Apollo compile time setup to map timestampCompile time setup is rather simple. We have to map the fully qualified target class name against our custom scalar. This is enough to convert our scalar to LocalDateTime.// File: &quot;app/build.gradle&quot;apollo { generateKotlinModels.set(true) customTypeMapping = [ &quot;timestamptz&quot; : &quot;org.threeten.bp.LocalDateTime&quot; ]}dependencies {...A peek through updated CustomType enum changes. TIMESTAMPTZ { override fun typeName(): String = &quot;timestamptz&quot; - override fun className(): String = &quot;kotlin.Any&quot;+ override fun className(): String = &quot;org.threeten.bp.LocalDateTime&quot;And in Expense class, the field type and deserializer changed.--- +++ import org.threeten.bp.LocalDateTime@@ -1,13 +1,13 @@ data class Expense( val __typename: String = &quot;expenses&quot;, val id: Int, val amount: Int, val remarks: String, val is_income: Boolean,- val created_at: Any+ val created_at: LocalDateTime // Now it&#39;s concrete ) { // Field deserialization - now takes LocalDateTime // instead of Any- val created_at = readCustomType&amp;lt;Any&amp;gt;(RESPONSE_FIELDS[5] as+ val created_at = readCustomType&amp;lt;LocalDateTime&amp;gt;(RESPONSE_FIELDS[5] as ResponseField.CustomTypeField)!!Now we have the type changed in generated classes. Yet, at runtime apollo doesn‚Äôt know how to create a LocalDateTime object from a timestamptz. Let‚Äôs provide the adapter in next step.3. Apollo runtime setup for parsing dateThis step is to convert string to Date and vice-verse. Threetenbp has DateTimeFormatter formatter class for this purpose. Let‚Äôs have a look at our sample date-time from our backend2021-05-13T04:00:49.815194+00:00This is of pattern yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSz. Let‚Äôs create a formatter for this.val formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSz&quot;)Now we create CustomTypeAdapter object to attach with apollo client. It has decode - encode functions to carry out the conversions. Using the above formatter, we can create an adapter like this,/** * Timestamp delivered as string from API. This adapter takes care of encode / decode the same. */private val timeStampAdapter = object : CustomTypeAdapter&amp;lt;LocalDateTime&amp;gt; { private val formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSz&quot;) override fun decode(value: CustomTypeValue&amp;lt;*&amp;gt;): LocalDateTime { return try { LocalDateTime.parse(value.value.toString(), formatter) } catch (e: Exception) { throw RuntimeException(&quot;Cannot parse date: ${value.value}&quot;) } } override fun encode(value: LocalDateTime): CustomTypeValue&amp;lt;*&amp;gt; { return try { CustomTypeValue.GraphQLString(formatter.format(value)) } catch (e: Exception) { throw RuntimeException(&quot;Cannot serialize the date date: ${value}&quot;) } }}Now map the adapter to the enum through ApolloClient.Builder.val apolloClient = ApolloClient .builder() .serverUrl(&quot;// url //&quot;) .addCustomTypeAdapter(CustomType.TIMESTAMPTZ, timeStampAdapter) .build()That‚Äôs it!! Now ApolloClient knows timestamp is LocalDateTime and we get a solid generated class to use in domain layer.GistOverall changes for the implementation is available as gistEndnoteNow we‚Äôve seen how to write adapters for a scalar, you might be in urge to create adapters for Enums. Don‚Äôt do it. Push it back to the backend and ask them to define it in schema. Apollo can generate enums if it is defined properly." }, { "title": "Weather forecast card design using Jetpack Compose", "url": "/posts/weather-card-compose/", "categories": "Android, Compose", "tags": "android, compose, dribbble", "date": "2021-05-15 00:00:00 +0530", "snippet": "Horizontal weather cards are the second portion in my forecast screen. It contains a message, relative timestamp and an image depicting the weather. Since I don‚Äôt have images in handy, I picked one and used for all the cards. I got creative with messages though. Why box layout? Designing a Weather Card Card content Card design Putting all in a Box Horizontal pager implementation Complete sourceWhy box layout?We have card and an image stacked in z order and they overlap. A constraint layout can be used to build this card, but I wanted to try box. It‚Äôs like FrameLayout to me. Also using constraint layout for simple layout is an overkill. Be it android native UI or Compose.Designing a Weather CardThe overall composable blueprint looks like in below image. To understand better, let‚Äôs build this layout bottom-up.‚Ä¶Card content// card contentColumn(modifier = Modifier.padding(16.dp)) { Spacer(modifier = Modifier.height(24.dp)) // Time Text( text = time, // &quot;20 minutes ago&quot;, style = MaterialTheme.typography.caption ) Spacer(modifier = Modifier.height(8.dp)) // Message Text( text = message, // &quot;If you don&#39;t want to get wet today, don&#39;t forget your umbrella.&quot;, style = MaterialTheme.typography.body1 ) Spacer(modifier = Modifier.height(24.dp))}Two labels wrapped in a Column with spacer makes our card content. Spacers are added in between the elements to make up required spacing between the labels and the parent (Column).‚Ä¶Card designNow put a card around it and apply few modifiers to it. a shape ‚Äî RoundedCornerShape top padding ‚Äî to make space for weather icon on top rightCard( shape = RoundedCornerShape(16.dp), modifier = Modifier .padding(top = 40.dp, start = 16.dp, end = 16.dp, bottom = 8.dp)) { Column(...)}‚Ä¶Putting all in a BoxBox layout stacks all the elements in given z order. Most recent one will be on the top. So, let‚Äôs put the Card first then the Image.Box { Card(...) Image( painter = painterResource(id = R.drawable.cloudy), contentDescription = &quot;weather overlap image&quot;, modifier = Modifier .size(100.dp) )} Hmm‚Ä¶ The rain wasn‚Äôt supposed to shower there. Let‚Äôs pull it to the right and shift a bit to the left. Children of Box has access to few properties to help with alignment inside the container. alignment ‚Äî Alignment.TopEnd offset ‚Äî x = (-40).dp negative translation in horizontal directionImage( painter = painterResource(id = R.drawable.cloudy), contentDescription = &quot;weather overlap image&quot;, modifier = Modifier .size(100.dp) .align(alignment = Alignment.TopEnd) .offset(x = (-40).dp))Horizontal pager implementationGoogle accompanist has an incredibly good set of extension for compose. To implement the pager &amp;amp; indicator, we need corresponding dependencies added to our codebase.implementation &quot;com.google.accompanist:accompanist-pager:0.9.0&quot;implementation &quot;com.google.accompanist:accompanist-pager-indicators:0.9.0&quot;Next step is to wrap the pager and indicator inside a Column and provide a list of mock objects to the render in WeatherCard that we built in above section.fun WeatherCardCarousal(cards: List&amp;lt;WeatherCard&amp;gt;) { val pagerState = rememberPagerState(pageCount = cards.size) Column { HorizontalPager( state = pagerState ) { page -&amp;gt; WeatherUpdateCard(cards[page]) } HorizontalPagerIndicator( pagerState = pagerState, modifier = Modifier .align(Alignment.CenterHorizontally) .padding(16.dp), ) }} pagerState provides the current index of element for the HorizontalPager WeatherUpdateCard(cards[page]) with the given index, corresponding element picked from mock data and rendered in WeatherCard HorizontalPagerIndicator placed below the pager to react with page swipes in Pager. If it needs to be overlapped on the Pager. We‚Äôll wrap them inside a Box and align it. This is again an example for thinking in compose. Pager updates the pagerState, and PagerIndicator reads the same. Both of ‚Äòem doesn‚Äôt know other component exist. Decoupled and yet communicating.Complete sourceEmbedded the entire gist below. If not loaded properly, use this link.Happy composing!!" }, { "title": "Why should I go for compose?", "url": "/posts/why-compose/", "categories": "Android, Compose", "tags": "android, compose, kotlin", "date": "2021-05-14 00:00:00 +0530", "snippet": "Way less boilerplate and better tooling. That‚Äôs why.What‚Äôs wrong with the old widgets?The old Android widget is painstakingly (smart!?) enough to has its own state and it is not necessarily in alignment with the viewmodel that represents it. Having references to the view widely encourages devs to update a view from another view. This often doesn‚Äôt end well.Few rare issues that you might‚Äôve faced Save button disabled even though the correct data present in the input box. To fix it user must delete a character and retype it. Incorrect tab header selected while the page is different. Switch/checkbox show in selected state, but it is in off state as per shared preferences. To make it align with the correct state, user must exit from the screen and come back. User see $0 total for a moment once landed on checkout screen. The list goes on..With the presence of ViewModel and LiveData, when effectively used, solves most of the above issues. Yet, there are two problems there to the core. View references that are available to other views Mutable views‚Ä¶What is Compose?Jetpack Compose is a modern UI toolkit for developing android apps. Compared to the native UI where we design in xml and bind using Kotlin/Java, @Composable functions are used in the toolkit to build UI around given data. Composable functions are dynamic, can bind data naturally and avoids boilerplate from old system.‚Ä¶Why compose?In compose UI kit, there are no referenceable views, a view either present or totally gone (I mean gone from the memory). A view cannot update other view directly ‚Äî Everything must go through a state variable. **Views are not there for their own sake but to represent data or collect it. ** Putting the data as a main player makes it easy to do validations independent of view and even share business logic between different UI clients.Write less, do moreA single Composable function can replace list item xml, view holder, recyclerview adapter and any callback set to propagate item clicks. Same goes for building compound components.This is the composable of below counter.@Composablefun Counter() { var count by remember { mutableStateOf(1) } Row { Icon(Icons.Sharp.RemoveCircleOutline, contentDescription = &quot;minus&quot;, modifier = Modifier .alpha(if (count &amp;gt; 1) 1f else .4f) .clickable { if (count &amp;gt; 1) { count-- } }) Text( count.toString(), textAlign = TextAlign.Center, modifier = Modifier .width(40.dp) ) Icon(Icons.Sharp.AddCircleOutline, contentDescription = &quot;plus&quot;, modifier = Modifier .alpha(if (count &amp;lt; 10) 1f else .4f) .clickable { if (count &amp;lt; 10) { count++ } }) }}‚Ä¶üßê Preview - interact - move onOnce you complete a @Composable, create a mock object (if needed) - feed it to composable through a @Preview function and interact with it ‚Äî right inside AndroidStudio!!. Even deploy it to your device.Imagine building a custom/compound component and testing it on device in old UI kit. The whole setup will require a dummy activity, run config changes, no need to say the cleanup afterwards.‚Ä¶üéº You‚Äôre really composing views To add an attribute to a composable: try a modifier or wrap it inside a container and apply modifier to it. Don‚Äôt set visibility at all, just don‚Äôt attach the view to tree A button with Text and Icon? Composable inside another composable is how you play it here.@Composablefun ShareButton() { var showIcon by remember { mutableStateOf(false) } Button(onClick = { showIcon = !showIcon }, shape = RoundedCornerShape(8.dp)) { if (showIcon) { Icon(Icons.Default.Share, contentDescription = &quot;share&quot; ) Spacer(Modifier.width(16.dp)) } Text(text = &quot;Share&quot;) }}‚Ä¶‚ú® Less error proneViews are inflated and then manipulated. A mandatory xml attribute might be missing for a custom view resulting in UI error. Composable are functions that reacts to the argument. Like any Kotlin function, nullable, non-nullable, default arguments can be defined here.‚Ä¶üß± Brick by brickTo keep the codebase clean, you‚Äôre forced to split a screen into multiple chunks of composables. So, you design brick by brick.Also, it means a fat object from API can be mapped into domain model composed of small chunks to align with independent UI development. So, we define finite set of inputs and UI states per chunk.This opens possibilities to reuse the composable in ways that would have been a nightmare before. Let‚Äôs say I have a composable that represents, user in a list view ‚Äî I can plug it inside my user details screen without any hassle.@Composablefun ProfileScreen(profile: Profile) { Column { ProfileListItem(profile.general) if (profile.flairs != null) { ProfileFlairs(profile.flairs) } ProfileBioContent(profile.bio) if (profile.achievements != null) { AchievmentListView(profile.achievements) } ProfileWorkExperience(profile.workExperience) }}To achieve the above, we‚Äôll have to create multiple custom views and explicit binding. Now the complete set of inflater, xml &amp;amp; view references and visibility changes are not needed anymore.‚Ä¶üá¶ TypographyCompose supports fontweights, this is something that designers and android devs don‚Äôt align with in widget ages. Finally, we‚Äôre one step closer to building what is in our mocks ‚Äî it sounds cool when we speak fontWeight to the designer. We have fontweight from Android 9, released in 2018. But we‚Äôre fragmented anyway.Text( text = &quot;Weight 700&quot;, fontWeight = FontWeight(700))Above and this ‚Äî annotatedString‚Ä¶üñ•Ô∏è Compose DesktopCompose desktop is a thing now. UI that is built for android should work for desktop as well. I have created separate project for both to play out. But haven‚Äôt shared the UI code yet. Even the package name in desktop carries androidx, let‚Äôs see how it goes. Furthermore read here.But compose destroys views on each event resulting in overhead ü§´No‚Ä¶ composable functions are smart enough to patch update only the dirty portions. This is called recomposition. Recomposition is set to skip as many composables possible on each pass. Read more about this here.Endnote:Above is purely my opinion about composable. Just sharing it here hoping fellow devs would add pro-cons. Developing native Android apps over years and felt painful some aspects of Native UI, trying Compose is very refreshing. For an analogy, this is like dealing with java and NPE for eternity and starting with Kotlin. (Also, I forgot, java mandates try-catch blocks and the semicolon)." }, { "title": "Jetpack compose ‚Äî DropdownMenu ‚Äî Weather UI", "url": "/posts/compose-dropdown/", "categories": "Android, Compose", "tags": "android, compose, dribbble", "date": "2021-05-13 00:00:00 +0530", "snippet": "IntroductionSharing my experience with jetpack while practicing with the weather - forecast screen(from uptechteam). While surfing dribble this particular shot caught my eye. Minimal - subtle colors also simple layout to implement. Best fit if you want to start with any UI framework.AnatomyThis page comprise of multiple sections, each will cover different ui element from compose. To make use of stacked layouts (box, row, column), I didn‚Äôt touch ConstraintLayout in this project. Top app bar ‚Üí Popup window Carousel of weather cards with indicator List of forecast for the weekAppbar - SpinnerApp bar holds a back arrow and a Spinner?!! that helps user to switch between cities. Let‚Äôs focus on the popup window part.In the old android system, this is a Spinner component with custom adapter (since we do color updates). This requires layouts defined for both anchor and list item, inflated at some point. Not to say about binding the content and updating the selected element. Enogh with old Views. Let‚Äôs see how to implement this in Jetpack.ImplementationAnchor viewCreate a Row container that holds the Text &amp;amp; Icon. This will act as anchor for dropdown and ensure clicking both items will show the menu.Box { // Back arrow here Row { // Anchor view Text(text = &quot;&quot;,) // City name label Icon(imageVector = Icons.Filled.ArrowDropDown,) }}Now we don‚Äôt see any city name displayed in it. We can take a param for the @Compose function and update it. But we expect the name to change while picking a city from menu. Thankfully, we have a nice way of doing this in Compose.// State variablesvar cityName : String by remember {mutableStateOf(cityList[0])}...Text(text = cityName,) // City name labelHere, cityName is a local state that update the UI once the value change. We set the initial value to first item in the list.‚Ä¶Dropdown menu designNow we have the AppBar UI ready, let‚Äôs design dropdown menu.var expanded by remember { mutableStateOf(false)}...Row { // Anchor view ... DropdownMenu( expanded = expanded, onDismissRequest = {}) { // TODO: Popup window content } }Here, we introduced a new state called expanded, which controls the visibility of menu. To show the window, we set it to true otherwise false. We know anchor controls the visibility, so add a click listener there. Row(Modifier.clickable { // Anchor view expanded = !expanded })Running this, we get ripple - nothing more. This is because, we haven‚Äôt setup the menu. Let‚Äôs jump to it. Before adding, the actual content, let‚Äôs experiment with popup content.DropdownMenu { Text(&quot;Popup content \\nhere&quot;, Modifier.padding(24.dp))}Now the menu is shown, but we cannot dismiss it. As we saw earlier, the expanded variable is the only thing that can control the visibility.But.. we toggle it on clicking on anchor. This is because, the click event is not delivered to the anchor (note.. no ripple). A different callback stole it. Let‚Äôs figure out what to do.DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false })The mandatory callback onDismissRequest , should be implemented to dismiss the menu. Otherwise, we‚Äôll endup with a sticky popup like in previous step.‚Ä¶Menu item designWe can place any Composable view in side the DropdownMenu. Current case, we need list of Label/Text in a column - each clickable. To keep the article short, I‚Äôm not demonstrating with a Column and Text list items. Keep these two points in mind and fast forward to the snippet. DropdownMenu places the given content inside column. So we don‚Äôt have to add a Column manually. From DropdownMenu source: @Composable fun DropdownMenu( expanded: Boolean, onDismissRequest: () -&amp;gt; Unit, ... properties: PopupProperties = PopupProperties(focusable = true), content: @Composable ColumnScope.() -&amp;gt; Unit ) Likewise, we have DropdownMenuItem container, which is a Row internally - can take care of placing line item‚Äôs content horizontally [ex. Country flag - Country name]. Also it ensures minimum height / width requirements met as per material design and has a click listener. From DropdownMenuItemContent source: @Composable internal fun DropdownMenuItemContent( onClick: () -&amp;gt; Unit, content: @Composable RowScope.() -&amp;gt; Unit ) ... Row() .sizeIn( minWidth = DropdownMenuItemDefaultMinWidth, maxWidth = DropdownMenuItemDefaultMaxWidth, minHeight = DropdownMenuItemDefaultMinHeight) Let‚Äôs make use of above containers and cook the list items.DropdownMenu(...) { cityList.forEach { city -&amp;gt; DropdownMenuItem(onClick = { }) { Text(city) } }}We get a list with clickable items, but menu not dismissed and value not updated. It‚Äôs just matter of implementing the onClick in menu-item.cityList.forEach { city -&amp;gt; DropdownMenuItem(onClick = { expanded = false cityName = city }) { Text(city) }}With bit of style customization to menu item, we can highlight the current city in menu.val isSelected = city == cityNameval style = if (isSelected) { MaterialTheme.typography.body1.copy( fontWeight = FontWeight.Bold, color = MaterialTheme.colors.secondary )} else { MaterialTheme.typography.body1.copy( fontWeight = FontWeight.Normal, color = MaterialTheme.colors.onSurface )}Text(text= city, style = style)‚Ä¶ConclusionWe can see the benefit of using composable here. In the old view system, Views has it‚Äôs own saved instance state backed by their ids this had few advantages, yet leaves the system unpredictable in many cases. Devs have to take care of keeping the UI and model in sync.In compose, data drives the UI. Take a look at cityName, initial value set to the component ‚Äî and then menu item click updates the variable name - not the Text/Label view. This is called unidirectional data flow. Data paints the UI, and UI updates the model. No UI vs UI communication happens here. That means, we don‚Äôt take value from the UI ‚Äî rather state can give it to us." }, { "title": "Sock merchant problem - Hackerrank", "url": "/posts/sock-merchant/", "categories": "Coding, Hackerrank", "tags": "coding", "date": "2021-05-06 00:00:00 +0530", "snippet": "Problem definition is available hereThis is a classification problem where the element can repeat multiple times in the given array.Like any other problem, this can be solved in multiple ways in kotlin.1. Elegant - yet non performant solutionfun sockMerchant(n: Int, ar: Array&amp;lt;Int&amp;gt;): Int { return ar.groupBy { it } .map { it.value.size/2 } // it is Map&amp;lt;Int, List&amp;lt;Int&amp;gt;&amp;gt; .sum()}This is a straightforward solution Read each value and create a map Map&amp;lt;Int, List&amp;lt;Int&amp;gt;&amp;gt; Convert each key-value-entry into integer by computing the size of value array Sum all elements in the integer list obtained from previous stepThough this looks elegant and kotlinish, we shouldn‚Äôt ignore the fact that it creates a Map with value list of identical elements. While what needed is just a counter mapped against each element.2. Old school - manual computationFor this classification problem, Map is the ideal datastructure for grouping.fun sockMerchant(n: Int, ar: Array&amp;lt;Int&amp;gt;): Int { val map = mutableMapOf&amp;lt;Int, Int&amp;gt;() for (s in ar) { map[s] = (map[s] ?: 0) + 1 } return map.values.fold(0) { acc, v -&amp;gt; acc + v/2 }}Here, we create a map Map&amp;lt;Int, Int&amp;gt; &amp;amp; increase the counter for each bucket. Then fold it. So, there is no value List&amp;lt;Int&amp;gt; created. Moreover, based on the unique values, the Map size constrained. At the end, the map values iterated through and folded into count.Wait.. There is still room for improvementWe need a consolidated count, not the per element pair count. That means, the fold function can be avoided by adding another line to the first loop.val map = mutableMapOf&amp;lt;Int, Int&amp;gt;()var pairCount = 0for (s in ar) { var count = (map[s] ?: 0) + 1 map[s] = count if (count % 2 == 0) { // For every second encounter, increase pairCount by one pairCount++ }}return pairCount Be kind to GC, few more lines of code won‚Äôt hurt" }, { "title": "Drawing book problem - Hackerrank", "url": "/posts/book-turns/", "categories": "Coding, Hackerrank", "tags": "coding", "date": "2021-05-04 00:00:00 +0530", "snippet": "Problem statement is available hereThis problem needs minimum number of turns required to reach a particular page.InputAll the books start with page1 on the left and may or may not fill the left side of the page.For a book contains n pages to reach page p, following is true. From front, turns (t) is always p/2. Below you can see few usecases page 1 --&amp;gt; 1/2 --&amp;gt; 0 page 2 --&amp;gt; 2/2 --&amp;gt; 1 page 3 --&amp;gt; 3/2 --&amp;gt; 1 page 4 --&amp;gt; 4/2 --&amp;gt; 2 i.e val turnsForPage = p/2 When coming from back, there might be a fluctuation. Due to last page being an odd or even number. For a book with 7 pages, reaching 2nd page from back takes 2 turns. [-,1] [2,3] [4,5] [6,7] If the book has 6 pages, the result is same [-,1] [2,3] [4,5] [6,-] For turn count computation from back, the last pair should be treated equally. As we know, the turn count from front is consistent one. Lets try it for the above books.val turnsForLastPage = n/26/2 = 37/3 = 3Now we know, the problem is never about the page number, but on which turn we land in it. With this is mind, lets build a table to visualize turns vs pages mapping. Turns [Front] 0 1 2 3 Turns[Back] 3 2 1 0 Page - pair _, 1 2, 3 4, 5 6, 7 From the table we know, Turn[Front] + Turn[Back] = turnsForLastPage.Let‚Äôs apply this and get Turn[Back] from above computations.val turnsFromLastPage = turnsForLastPage - turnsForPageSolutionSo the complete solution is as belowfun pageCount(n: Int, p: Int): Int { val turnsForPage = p/2 val turnsFromLastPage = n/2-turnsForPage return Math.min(turnsForPage, turnsFromLastPage)}" }, { "title": "Kotlin value class", "url": "/posts/kotlin-value-class/", "categories": "Kotlin", "tags": "kotlin, android", "date": "2021-05-01 00:00:00 +0530", "snippet": "Kotlin‚Äôs data class is a fan favorite when it comes to storing any model. Bundled with bunch of necessary methods, devs get a lot while writing way less. From Kotlin 1.5 ‚Äî we have value class-s. Let‚Äôs see what is a value class and where to use it.While data class is used for holding model, value class adds attribute to a value and constraint it‚Äôs usage. This class is nothing but a wrapper around a value, but the Kotlin compiler makes sure there is no overhead due to wrapping. The problem A no-brainer solution Enter kotlin - value class ByteCode of normal wrapper Endnote:The problemDuration is a classical problem where anyone can make mistake, if they didn‚Äôt read between the lines. So, I wrote a function to show a tooltip message for given duration in millis. The signature looks like this.fun showTooltip(message: String, duration: Long) { ... }To make sure the caller pass in correct duration, I can do this.fun showTooltip(message: String, durationInMillis: Long) { ... }even this,/*** Shows tooltip of message for given duration* @param message - message to display* @param durationInMillis - duration in milliseconds**/fun showTooltip(message: String, durationInMillis: Long) { ... }Despite all the naming and documentation, someone can invoke the tool tip with seconds. After all NASA lost a spacecraft due to a unit mistake.showTooltip(&quot;I&#39;m going to pass duration in seconds&quot;, 2L)A no-brainer solutionTo make sure, the user pass in millseconds, the duration can be wrapped in a class, and retrict the object creation to few meaningful helper methods, this wrapper class can make sure proper value passed in to the method.class Duration private constructor ( val millis: Long) { companion object { fun millis(millis: Long) = Duration(millis) fun seconds(seconds: Long) = Duration(seconds * 1000) }}fun showTooltip(message: String, duration: Duration) { println(&quot;Will show $message for ${duration.millis} milliseconds&quot;)}...showTooltip(&quot;Hello - Seconds&quot;, Duration.seconds(2L))showTooltip(&quot;Hello - Millis&quot;, Duration.millis(1200))...Now the showTooltip function takes in Duration and process it in millis. This ensures the caller send proper duration to the function and showTooltip can rely on the Duration#millis field.However, for each duration usage, we box it inside a object, just to avoid communication gap. To pass in a parameter, a new object is created and allocated in memory.Enter kotlin - value classThe Kotlin value class wraps a single value and thus impose any restriction/conversion to it. Kotlin compiler takes away the boxing in possible cases to deliver performance.@JvmInlinevalue class Duration private constructor ( val millis: Long) { companion object { fun millis(millis: Long) = Duration(millis) fun seconds(seconds: Long) = Duration(seconds * 1000) }}We don‚Äôt see much difference but just two new keywords. But under the hood, a normal Duration class and value class is different altogether. I‚Äôm leaving the value class byte code here. In case you wonder how the normal class looks in bytecode, read through this and then reach to ByteCode of normal wrapper section.// Duration -- value class bytecodepublic final class Duration { private final long millis; private Duration(long millis) { this.millis = millis; } public static final class Companion { // Comapanion that outputs Duration is mangled to return the wrapped value public final long millis_PZfE49U/* $FF was: millis-PZfE49U*/(long millis) { return Duration.constructor-impl(millis); } // Comapanion that outputs Duration is mangled to return the wrapped value public final long seconds_PZfE49U/* $FF was: seconds-PZfE49U*/(long seconds) { return Duration.constructor-impl(seconds * (long)1000); } }}// Caller function name mangledpublic static final void showTooltip_fxiZ0zM/* $FF was: showTooltip-fxiZ0zM*/(@NotNull String message, long duration) { ...}...// Invoking the function that consumes value class param.showTooltip_fxiZ0zM(&quot;&quot;, Duration.Companion.millis_PZfE49U(2000L)); showTooltip_fxiZ0zM(&quot;&quot;, Duration.Companion.seonds_PZfE49U(2L));As you see, where ever the Duration object used, the function names are mangled and the param // output type changed to Long.In case you wonder why the mangling is needed here, this avoids any conflict resolution when the function signature matches the wrapped type.// Using a wrapped value argfun showTooltip(message: String, duration: Duration) {...}// Using a primitive value as argfun showTooltip(message: String, duration: Long) {...}If the compiler just replace the param type with wrapped primitive here, the code won‚Äôt compile. So it is necessary to mangle up the name.ByteCode of normal wrapperpublic final class Duration { private final long millis; private Duration(long millis) { this.millis = millis; } public static final class Companion { // Companion function return the wrapped object public final Duration millis(long millis) { return new Duration(millis, (DefaultConstructorMarker)null); } // Companions function return the wrapped object public final Duration seconds(long seconds) { return new Duration(seconds * (long)1000, (DefaultConstructorMarker)null); } }}// Called function signature looks samepublic static final void showTooltip(String message, Duration duration) { ...}// Caller is showTooltip(&quot;&quot;, Duration.Companion.seconds(2L));showTooltip(&quot;&quot;, Duration.Companion.millis(1200L));That‚Äôs what a normal wrapper class look like. In case you wonder why did I use a normal class instead of a data class. See below.data class Duration private constructor( val millis: Long) { // Same companion as normal class}public final class Duration { private Duration(long millis) { this.millis = millis; } public final long component1() { return this.millis; } @NotNull public final Duration copy(long millis) { return new Duration(millis); } // Same companion byte code from normal class ...}data class creates a copy method, which allows you to create Duration given a long param. Our goal is to restrict the object creation to the companion methods. Also data class leaves a componentN function, which we don‚Äôt need in this case. We‚Äôre just trying to wrap the value here.Endnote:Since Kotlin 1.2.xx, we have inline classes, the old name for the value class. Since the class is not actually inlined in comparison to the inline function, it has been renamed to value class and the inline keyword is deprecated now." }, { "title": "Hackerrank - bon-appetit problem solution in Kotlin", "url": "/posts/bon-apetit/", "categories": "Kotlin", "tags": "kotlin", "date": "2021-04-30 00:00:00 +0530", "snippet": " 1. sumBy 2. sumOf 3. foldIndexed 4. reduceIndexed 5. filterIndexed + sum() 6. fold 7. reduce Solution:For detailed problem statement, head over to the bill division problem hereFrom the problem definition, we get two things Element at index k should not be considered for bill computation Rest of the elements should be added and then share computed by dividing the total by twoBear in mind that division should be done after computing the total. So, below I listed few aggregators to compute the sum from array (excluding an index). There are more ways to achieve this in kotlin. Each has slight difference and some of them are improved version of other.1. sumByarray.withIndex().sumBy { // IndexedValue&amp;lt;Int&amp;gt; if (it.index != k) { it.value } else { 0 }}Above creates an IndexingIterable, emits IndexedValue&amp;lt;Int&amp;gt; for each item and consumed by the sumBy function2. sumOfarray.withIndex().sumOf { // IndexedValue&amp;lt;Int&amp;gt; if (it.index != k) { it.value } else { 0 }}sumOf follows the same footprint of sumBy. Only difference is sumOf can return different result type (ex. Double or Long instead of Int). Below snippet explains the usage of each sum function.val totalInt = array.sumBy { it }val totalDouble1 = array.sumBy { it.toDouble() } //Error: Type mismatchval totalDouble2 = array.sumByDouble { it.toDouble() }val totalDouble3 = array.sumOf { it.toDouble() }3. foldIndexedarray.foldIndexed(0) { index, acc, value -&amp;gt; acc + if (index == k) { 0 } else { value }}foldIndexed function takes in a initial value and an operation lambda to operate on the element. Notice the lambda returns the accumulated value on each iteration. Unlike sum functions which need an element to operate on, here the operation owned by the us.4. reduceIndexedarray.reduceIndexed { index, acc, value -&amp;gt; acc + if (index == k) { 0 } else { value }}reduceIndexed is similar to foldIndexed function, and it lacks the initial value.There are few downsides using reduce instead of fold: If the array is empty, reduce function will throw UnsupportedOperationException java.lang.UnsupportedOperationException: Empty array can‚Äôt be reduced Accumulated value result type cannot be different from the array element type Functions listed above operates on original array and computes the result. Below ones creates a filtered list out of original array, it can be used to perform operations on it.5. filterIndexed + sum()array .filterIndexed { index, _ -&amp;gt; index != k } .sum()6. foldarray .filterIndexed { index, _ -&amp;gt; index != k } .fold(0) { acc, value -&amp;gt; acc + value }7. reducearray .filterIndexed { index, _ -&amp;gt; index != k } .reduce{ acc, value -&amp;gt; acc + value }Solution:Here is the complete solution to the problem.fun bonAppetit(bill: Array&amp;lt;Int&amp;gt;, k: Int, b: Int): Unit { val diff = b - bill.foldIndexed(0) { i, total, v -&amp;gt; if (i != k) { total + v } else { total } }/2 println(if (diff == 0) { &quot;Bon Appetit&quot; } else { diff })}Edit: I left out the loop statements here to focus on aggregators. Feel free to comment if anything else turns up, I‚Äôll add it to the list." }, { "title": "Electronic store problem - Hackerrank - Kotlin solution - elimination approach", "url": "/posts/electronic-store/", "categories": "Coding, Hackerrank", "tags": "kotlin, coding", "date": "2021-04-27 00:00:00 +0530", "snippet": "IntroductionProblem definition is available hereOur goal is to compute the costly pair of keyboard &amp;amp; drive we can get from the the store, given the budget (b).The input is keyboards and drives cost arrays and budget.We‚Äôll start with brute force approach and optimize the solution around it. Introduction Brute force Sorted input Solution Edit ConclusionBrute forceGiven two arrays of size m and n, the brute force will check each pair and compare against the current max value and the budget. So, m*n pair checks will be made to find the result.fun getMoneySpent(keyboards: Array&amp;lt;Int&amp;gt;, drives: Array&amp;lt;Int&amp;gt;, b: Int): Int { var pairChecks = 0 var max = -1 for ( k in keyboards) { for (d in drives) { val total = k + d if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total } } } println(&quot;$pairChecks pairs checked&quot;) return max}// Input 1Budget : 5Keyboards = [6, 5, 3, 7, 1]Drives = [2, 3, 7]For the input1, we get 5x3 = 15 pairs checked. Going through the input we can see the pair would be [3, 2] which meets the budget of 5. Checking anything further is wasting CPU resource. Let‚Äôs add some checks and see further.outer@for ( k in keyboards) { for (d in drives) { val total = k + d if (total == b) { // budget met here, exit the loop max = total break@outer } if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total } pairChecks++ } } Output: 7 pairs checkedWith this best-case budget check, we get only 7 pairs checked which nice, but it‚Äôs not every day you meet the magic number. Going through the input again, it‚Äôs evident some keyboards are costlier than our budget. For each costly keyboard, we can save 3 iterations.outer@for ( k in keyboards) { if (k &amp;lt; b) { for (d in drives) { val total = k + d if (total == b) { max = total break@outer } if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total } pairChecks++ } } } Output: 1 pairs checkedThat‚Äôs not bad. But we know the output is specific to this input set. Adjusting one parameter in the input set will affect the pair checks.// Input 2Budget : 4Keyboards = [6, 5, 3, 7, 1]Drives = [2, 3, 7]Take input2, where we are short of a dollar in the budget, and the output is, 5 pairs checked// Input 3Budget : 60Keyboards = [40, 50, 59]Drives = [5, 8, 12]Let‚Äôs take another input :: input3 and check the result. 9 pairs checkedSo, whatever the optimization that we did, the input3 just didn‚Äôt fit in. We‚Äôre relying on best case to break the loop, as the input is not ordered is some manner. If the input is ordered beforehand, we‚Äôll get best results.Sorted inputA sorted input has impact on how we compute the output.// Input 4Budget : 60Keyboards = [59, 50, 50, 40] // descending orderDrives = [5, 8, 12, 14] // ascending orderWith current implementation, we get all the pairs checked in input 4. 16 pairs checkedLet‚Äôs take advantage of sorted arrays. Below we can visualize the sum for each pair. And form a hypothesis on how to eliminate extra iterations. ¬† 5 8 12 14 59 64 67 71 73 50 55 58 62 64 50 55 58 62 64 40 45 48 52 54 At [0, 0] the pair is already past the budget, which means [0,1] and [0,2] will exceed the budget (since drives will get costlier going right). So, we can break the inner loop and read from next row.outer@for ( k in keyboards) { if (k &amp;lt; b) { inner@for (d in drives) { pairChecks++ ... if (total &amp;gt; b) { // For sorted array, if the total is already past the budget, it&#39;s not going to come down. break@inner } ... } } }Now the output is 11 pairs checkedNow we have avoided few elements towards the right. ¬† 5 8 12 14 59 64 67 71 73 50 55 58 62 64 50 55 58 62 64 40 45 48 52 54 Notice‚Ä¶ for any column, the numbers getting smaller as we move downward. This is due to the descending order sorted keyboards array. So, we don‚Äôt have to check this column (call cMax) anymore. ¬† 5 8 12 14 59 64 67 71 73 50 55 58 62 64 50 55 58 62 64 40 45 48 52 54 For a given column, elements on the left will be smaller (since the drives array is sorted in ascending order). So, we can strike down any element to the left of cMax. ¬† 5 8 12 14 59 64 67 71 73 50 55 58 62 64 50 55 58 62 64 40 45 48 52 54 We are going to use index for looping through the columns. So, few modifications needed for the inner loop. var cMax = -1 outer@for ( k in keyboards) { if (k &amp;lt; b) { inner@for (dIndex in (cMax + 1) until drives.size) { val d = drives[dIndex] ... } } }We haven‚Äôt changed the iteration logic yet, instead of forEach, we‚Äôre using the index now. cMax will be our shifting pointer to start loop in each row. This value must be assigned each time we find the max value.if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total cMax = dIndex}With index shifting, we have the expected pair checks as in the table. 7 pairs checkedRemember, the solution expects the arrays to be sorted in above manner. So, we must sort the inputs beforehand. Since we already have better sorting algorithms, we can use inbuilt ones to do it. So, the complete solution looks like this.Solution// Solution - for loopfun getMoneySpent(keyboards: Array&amp;lt;Int&amp;gt;, drives: Array&amp;lt;Int&amp;gt;, b: Int): Int { // Data preparation keyboards.sortDescending() drives.sort() var max = -1 var cMax = -1 // Which column holds the current max outer@for ( k in keyboards) { if (k &amp;lt; b) { inner@for (dIndex in (cMax + 1) until drives.size) { val d = drives[dIndex] val total = k + d if (total == b) { max = total break@outer } if (total &amp;gt; b) { break@inner } if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total cMax = dIndex } } } } return max}EditThis solution is bit clumsy as we started with for loop and refined over time.I removed the check where keyboard cost being greater than budget. Now it will cost at most one iteration compared to the brute force method.fun getMoneySpent(keyboards: Array&amp;lt;Int&amp;gt;, drives: Array&amp;lt;Int&amp;gt;, b: Int): Int { var max = -1 var cMax = -1 // Which column holds the current max outer@for ( k in keyboards) { inner@for (dIndex in (cMax + 1) until drives.size) { val d = drives[dIndex] val total = k + d if (total == b) { max = total break@outer } if (total &amp;gt; b) { break@inner } if (total &amp;lt;= b &amp;amp;&amp;amp; total &amp;gt; max) { max = total cMax = dIndex } } } return max} Throw away the prototypeWith lessons learned from above implementation, it is clear that index plays a key role here. So, implemented the same using while loop.// While loop solutionfun getMoneySpent2(keyboards: Array&amp;lt;Int&amp;gt;, drives: Array&amp;lt;Int&amp;gt;, b: Int): Int { var max = 0 keyboards.sortDescending() drives.sort() var i = 0 var j = 0 while(i &amp;lt; keyboards.size) { while (j &amp;lt; drives.size) { val total = keyboards[i] + drives[j] if ( total &amp;gt; b) break // Here we eliminate moving towards right if ( total &amp;gt; max) { max = total } j++ // This is equivalent to cMax+1 } i++ } return max}ConclusionIt might look like overhead to sort the arrays before computation. This will work out well on a long run in the following cases Eliminating the elements to the right, left and bottom with current max will drastically bring down comparisons in large data set. This solution can be scaled to provide weightage to the products. eg. For a costlier keyboard, find a cheap mouse Keep the keyboard cost below 70% budget Sorting can give a clarity while applying any of the above constraints." }, { "title": "Kotlin safe casting", "url": "/posts/kotlin-safe-cast/", "categories": "Kotlin", "tags": "android, kotlin", "date": "2021-04-14 00:00:00 +0530", "snippet": "In multiple cases you might‚Äôve came across the situation where you have to cast a global variable and check the instance beforehand.A most common case in Android environment is to check whether the (hosting) activity implements a callback or extended from Specific one.Beforeif (activity is BaseActivity) { (activity as BaseActivity).hideKeyboard()}AfterSame can be written in sweet Kotlin syntax in a single line(activity as? BaseActivity)?.hideKeyboard()From the official doc Use the safe cast operator as? that returns null on failure.How this is better?In surface it might not look like a better code overhaul. As calls to activity increase in numbers, it gets better.// CreateTweetFragment.ktfun submit() { // Fire and forget API call if (activity is BaseActivity) { (activity as BaseActivity).hideKeyboard() } if (activity is TweetSubmittedCallback) { (activity as TweetSubmittedCallback).onTweetSubmitted() }}We could easily cast the activity to the exact subclass and invoke both methods.// CreateTweetFragment.ktfun submit() { // Fire and forget API call if (activity is TwitterActivity) { (activity as TwitterActivity).hideKeyboard() (activity as TwitterActivity).onTweetSubmitted() }}But it enforces the CreateTweetFragment to be attached to the TwitterActivity to execute both statements. Anything that is just a BaseActivity or TweetSubmittedCallback won‚Äôt execute the statement even though the implementation is in place. Prefer composition over inheritanceNow with the as? operator, both statements can be executed independent of each other.fun submit() { // Fire and forget API call (activity as? BaseActivity)?.hideKeyboard() (activity as TweetSubmittedCallback)?.onTweetSubmitted()}" } ]
